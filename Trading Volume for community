//@version=5
indicator('Buy Bot Volume Indicator', max_bars_back = 5000,max_boxes_count=200, overlay = false)

//Buy Bot Volume Indicator
//Copyright (C) 2025 MrM - Manuel
 
// Questo programma è software libero: puoi ridistribuirlo e/o modificarlo
// secondo i termini della GNU General Public License come pubblicata dalla
//Free Software Foundation, sia la versione 3 della Licenza, sia
//(a tua scelta) una versione successiva.
 
//Questo programma è distribuito nella speranza che sia utile,
//ma SENZA ALCUNA GARANZIA; senza neppure la garanzia implicita di
//COMMERCIABILITÀ o IDONEITÀ PER UN PARTICOLARE SCOPO. Vedi la
//GNU General Public License per maggiori dettagli.
 
//Dovresti aver ricevuto una copia della GNU General Public License
//insieme a questo programma. In caso contrario, vedi <https://www.gnu.org/licenses/>.
 
//Contatto: manuelmarmaglio@gmail.com (oggetto: TRADING)

///////////         BBars DEVE AVERE UN NUMERO PARI !!!!!

// Starter Pack
// -----------------------------------------------------------{
 
// Var
// -----------------------------------------------------------{
var bool show_plot = true
//Bars VLR  
//Numero di barra da prendere in esame nello studio iniziale del grafico 
bbars                   = input.int(title='Number of Bars - inserire un numero pari', defval=400, minval=1)
var int original_bbars  = bbars
//indica la % di volume da pesare per scegliere vah e val, questa % verrà riadattata automaticamente e sarà fittizia in quanto il codice tenderà a forzare l'ampiezza in base ai livelli di ratio
var percent             = input.float(title='% pesata di volume', defval=65, minval=1, maxval = 100) 
int bbars_2             = bbars / 2
var int bar_limit       = 1500 //Il numero delle barre oltre il quale l'indicatore si estenderà senza continuare lo studio (massimo di computazione possibile)
//Se utilizzato come alert e non per la visualizzazione la sua potenza computazionale dovrebbe reggere fino a 4999 barre
var bool ancoraggio_pivot = true //Questa bool serve per ancorare la bbars al pivot quando run == 1 
var bool auto_pivot_vol               = true // Attivando questa bool le posizioni cover si adattano al volume di gioco attuale, disattivandolo il valore standard sarà considerato come valore costante
var bool fast_play                    = true //Attivare questa bool per usare il primo pivot sotto quello attuale a prescindere dalla sua distanza dal pivot corrente (Se ne consiglia l'attivazione per non allontanara il pivot reale nella gestione delle posizioni bot)
//Var generali 
var bool block_start_bar          = false 
var bool up_breakout              = false // Necessita revisione in fase di start, al momento non tengo conto qual è il reale pivot attivo nella gestione dell'ancoraggio, questo causa errori di calcolo non fondamentali ma comunque fastidiosi
var bool down_breakout            = false // Necessita revisione in fase di start, al momento non tengo conto qual è il reale pivot attivo nella gestione dell'ancoraggio, questo causa errori di calcolo non fondamentali ma comunque fastidiosi 
var float distanza_break_out_down = na 
var float top_in_down_break_out   = na 
var bool fast_cover_setting = true // Gestione posizioni di cover su tutte le inefficienze di mercato, disattivandolo si cercano inefficienze più profonde
var float incremento_distanza_pivot = 1.5   //Variabile per incrementare la distanza delle posizioni cover, una sua revisione in base al timeframe o al vix potrebbe essere opportuna
var float incremento_resistenze_pivot = 1.5 //Variabile per incrementare la distanza delle posizioni cover, una sua revisione in base al timeframe o al vix potrebbe essere opportuna
var float run     = 0
var int contatore = 0 //Gestisce il numero di barre da aggiungere a bbars
var color headerColor = color.new(color.gray, 20)
var color positiveColor = color.new(color.green, 60)
var color negativeColor = color.new(color.red, 60)
var color vah_color = na 
var color val_color = na 
var int tot_position = 0 
var int tot_position_cover = 0 
var bool bot_liq_modified = false //Questo blocco trova le inefficienze di apertura di mercato e comprime le relative liquidità di zona
var bool top_liq_modified = false //Questo blocco trova le inefficienze di apertura di mercato e comprime le relative liquidità di zona
var string current_timeframe = timeframe.period
var float min_0_3 = close / 100 * 0.2 // Minimo sindacale per la distanza delle posizioni cover, aumentandolo aumenta la distanza delle posizioni cover
//

// Inizializzazione della variabile
var int timeframe_level = na 

// Assegnazione del livello in base al timeframe
if run == 0
    // Timeframe fino a 15 secondi = livello 0
    if current_timeframe == "1S" or 
         current_timeframe == "5S" or 
         current_timeframe == "10S" or 
         current_timeframe == "15S" 
        timeframe_level := 0 
    
    // Timeframe da 30s a 2 minuti = livello 1
    if current_timeframe == "30S" or 
         current_timeframe == "45S" or 
         current_timeframe == "1" or
         current_timeframe == "2"
        timeframe_level := 1
    
    // Timeframe da 3 a 10 minuti = livello 2
    if current_timeframe == "3" or 
         current_timeframe == "5" or 
         current_timeframe == "10"
        timeframe_level := 2
    
    // Timeframe da 15 a 45 minuti = livello 3
    if current_timeframe == "15" or 
         current_timeframe == "30" or 
         current_timeframe == "45"
        timeframe_level := 3
    
    // Timeframe da 1 ora a 4 ore = livello 4
    if current_timeframe == "60" or 
         current_timeframe == "120" or 
         current_timeframe == "180" or 
         current_timeframe == "240"       
        timeframe_level := 4
    
    // Timeframe superiori = livello 5
    if current_timeframe == "D" or 
         current_timeframe == "W" or 
         current_timeframe == "M"
        timeframe_level := 5
     
// ----------------------------------------}

// Gestione titoli e timframe
// -----------------------------------------------------------{

var float spread = na
var string titolo = na 
var float n_titoli = na 

if na(titolo) 
    titolo := syminfo.ticker 
    //Indici o driver tradabili 
    if titolo == "US30" 
        spread := 2 
        n_titoli := na  
    if titolo == "TECDAX" 
        spread := 11 
        n_titoli := na  
    if titolo == "US100" 
        spread := 1.8 
        n_titoli := na  
    if titolo == "GOLD" 
        spread := 0.1
        n_titoli := na  
    if titolo == "DE40" 
        spread := 1.5 
        n_titoli := na  
    if titolo == "NYFANG" 
        spread := 4 
        n_titoli := na  
    if titolo == "US500" 
        spread := 0.02
        n_titoli := na 
    if titolo == "BTCUSD" 
        spread := 50 
        n_titoli := na  
    if titolo == "EURUSD" 
        spread := 0.00006 
        n_titoli := na  
    if titolo == "OIL_CRUDE" 
        spread := 0.03 
        n_titoli := na  
    if titolo == "RTY" 
        spread := 0.5 
        n_titoli := na  
    if titolo == "HK50" 
        spread := 30 
        n_titoli := na  
    if titolo == "FR40" 
        spread := 0.8 
        n_titoli := na  
    if titolo == "IT40" 
        spread := 18 
        n_titoli := na  
    //Stock Us 
    if titolo == "UNH" 
        spread := 0.3 
        n_titoli := na   
    if titolo == "MSFT" 
        spread := 1.1 
        n_titoli := na  
    if titolo == "GOOG" 
        spread := 0.22 
        n_titoli := na  
    if titolo == "TSLA" 
        spread := 0.37 
        n_titoli := na  
    if titolo == "NVDA" 
        spread := 0.11 
        n_titoli := na  
    if titolo == "AMZN" 
        spread := 0.17 
        n_titoli := na  
    if titolo == "META" 
        spread := 1.6 
        n_titoli := na  
    if titolo == "AAPL" 
        spread := 0.27 
        n_titoli := na  
    if titolo == "PEP" 
        spread := 0.18 
        n_titoli := na  
    if titolo == "NFLX" 
        spread := 1.98 
        n_titoli := na  
    if titolo == "C" 
        spread := 0.7
        n_titoli := na  

    //Stock Eu 
    if titolo == "KER" 
        spread := 0.4 
        n_titoli := na  
    if titolo == "LDO" 
        spread := 0.25 
        n_titoli := na  
    if titolo == "RACEM" 
        spread := 1.04
        n_titoli := na 
    if titolo == "CPR" 
        spread := 0.025 
        n_titoli := na  
    if titolo == "RHM" 
        spread := 4
        n_titoli := na  
    if titolo == "NEXI" 
        spread := 0.10
        n_titoli := na  
    if titolo == "ASML" 
        spread := 1.5
        n_titoli := na  
    //

// Percentili VIX predefiniti
var float p05 = 12.29
var float p15 = 13.15
var float p35 = 15.38
var float p50 = 16.55
var float p70 = 19.27
var float p85 = 22.65
var float p93 = 26.91
var float p98 = 33.81

// Ottieni l'ultimo valore del VIX
vix = request.security("VIX", current_timeframe, close)

// Determina lo stato del VIX tramite semplici confronti
status = vix >= p98 ? "PANICO" :
         vix >= p93 ? "CRITICO" :
         vix >= p85 ? "ALTO" :
         vix >= p70 ? "ELEVATO" :
         vix >= p50 ? "NORMALE" :
         vix >= p35 ? "BASSO" :
         vix >= p15 ? "MOLTO BASSO" :
         "COMPIACENZA"
//

//Questa sezione gestisce la distanza percentuale dei livelli di target rispetto ai livelli che vengono triggerati, necessitano una riformattazione più precisa
var int min_level = na
var int mid_level = na
var int sentiment_level = 0 
if status == "PANICO" or status == "CRITICO"
    min_level := 25
    mid_level := 35
    incremento_distanza_pivot := 1.4
    sentiment_level := 0
if status == "ALTO" 
    min_level := 28
    mid_level := 38
    incremento_distanza_pivot := 1.3
    sentiment_level := 1
if status == "ELEVATO" 
    min_level := 30
    mid_level := 40
    incremento_distanza_pivot := 1.2
    sentiment_level := 2
if status == "NORMALE" 
    min_level := 35
    mid_level := 50
    incremento_distanza_pivot := 1.1
    sentiment_level := 3
if status == "MOLTO BASSO" or status == "BASSO"
    min_level := 40
    mid_level := 55
    incremento_distanza_pivot :=  1
    sentiment_level := 4
//

// Colore basato sullo stato
col = vix >= p93 ? color.red :
      vix >= p85 ? color.orange :
      vix >= p70 ? color.yellow :
      vix >= p35 ? color.gray :
      color.green

// Tabella base
var table t = table.new(position.bottom_center, 2, 2, force_overlay = false)

// Aggiorna la tabella solo sull'ultima barra
if barstate.isconfirmed and show_plot
    table.cell(t, 0, 0, "VIX", text_color=color.white)
    table.cell(t, 1, 0, str.tostring(vix, "#.##"), text_color=color.yellow)
    table.cell(t, 0, 1, "STATO", text_color=color.white)
    table.cell(t, 1, 1, status, text_color=col)
//

// ----------------------------------------}

// Strutture di base
// -----------------------------------------------------------{

var a_sup         = array.new_float(0)
var float actual_supporto    = na 
var float actual_resistenza  = na 
var int   support_switch_bar = na 
var int   res_switch_bar = na 
var float bot                   = na
var float top                   = na
var float distanza_break_out_up = na 
var float bot_in_up_break_out   = na 
var float bot_liq  = na //Liquidità base ancorata a pivot 1,1
var float top_liq  = na //Liquidità base ancorata a pivot 1,1
var float save_bot_liq  = na //Salvo le liquidità in modo da mantenerle stabili quando le bbars superano il bar limit
var float save_top_liq  = na //Salvo le liquidità in modo da mantenerle stabili quando le bbars superano il bar limit

var float actual_old_supporto = na 
var float actual_old_resistenza = na 
var int support_switch_bar_old = na 
var int res_switch_bar_old = na 
var bool  bot_is_sup = false //Definisce se i pivot corrispondono al livello bot
var bool  top_is_res = false //Definisce se i pivot corrispondono al livello top

//Vengono confrontati diversi livelli di pivot, il pivot old e quello normale servono per i margini di gioco, quelli fast per il sistema ad inefficienza rapida per le posizioni cover (rappresenza un rischio a timeframe bassi quando la volatilità implicita è elevata e vengono infinte usati dei sistemi di pivot 1,1 per controllare la liquidità interna (pivot basso per top e alto per bot))
//Gestione supporti e resistenze 
supporto   = bar_index > 1000 ? ta.pivotlow  (low,  bbars_2, bbars_2)   : na 
resistenza = bar_index > 1000 ? ta.pivothigh (high, bbars_2, bbars_2)   : na 

switch_supporto   = not na(supporto)
switch_resistenza = not na(resistenza)

if switch_supporto    
    actual_supporto         := supporto  
    support_switch_bar      := bar_index - bbars_2 - 1 // Indica il punto in cui il low corrisponde all'actual supporto 
    if not fast_cover_setting
        array.push(a_sup, supporto)

    if bot_liq_modified 
        bot_liq_modified := false 
//

if switch_resistenza  
    actual_resistenza   := resistenza  
    res_switch_bar      := bar_index - bbars_2 - 1 // Indica il punto in cui il low corrisponde all'actual supporto 
    if not fast_cover_setting
        array.push(a_sup, resistenza)

    if top_liq_modified 
        top_liq_modified := false 
//

supporto_fast   = bar_index > 1000 ? ta.pivotlow  (low,  13, 13)   : na 
resistenza_fast = bar_index > 1000 ? ta.pivothigh (high, 13, 13)   : na 

switch_supporto_fast   = not na(supporto_fast)
switch_resistenza_fast = not na(resistenza_fast)

if switch_supporto_fast    
    if fast_cover_setting
        array.push(a_sup, supporto_fast)
//

if switch_resistenza_fast  
    if fast_cover_setting
        array.push(a_sup, resistenza_fast)
//

var int original_bbars_old = original_bbars -1
//Gestione supporti e resistenze 
supporto_old   = bar_index > 100 ? ta.pivotlow  (low,  original_bbars_old, original_bbars_old)   : na 
resistenza_old = bar_index > 100 ? ta.pivothigh (high, original_bbars_old, original_bbars_old)   : na 

switch_supporto_old   = not na(supporto_old)
switch_resistenza_old = not na(resistenza_old)

if switch_supporto_old    
    actual_old_supporto := supporto_old 
    support_switch_bar_old      := bar_index - original_bbars_old - 1 // Indica il punto in cui il low corrisponde all'actual supporto 

//
if switch_resistenza_old  
    actual_old_resistenza := resistenza_old 
    res_switch_bar_old      := bar_index - original_bbars_old - 1 // Indica il punto in cui il low corrisponde all'actual supporto 
//

// Elimino i pivot non vergini dall'array, iterando sia supporti che resistenze nello stesso array vengono prese le inefficienze di apertura di mercato come posizione cover.
int size = array.size(a_sup)
for i = 0 to size - 1
    int j = size - 1 - i
    if j >= 0 and j < array.size(a_sup)  // Controllo di sicurezza
        level = array.get(a_sup, j)
        if high >= level and low <= level
            array.remove(a_sup, j)
//

var bool bot_block      = false 
var bool top_block      = false  
var bool bot_block_fast = false 
var bool top_block_fast = false 

var float actual_media_vol = na 

//Utilizzo bot max quando le bbars non sono bloccate, questo evita problemi di iterazione di ta. che oggettivamente fanno schifo se modificati in lenght
bot_max = ta.lowest(low, original_bbars)
top_max = ta.highest(high, original_bbars)
//
var float media_mom = na 

var int contatore_media = 0
var float media = 0
var float media_vol = na 
if run == 0 and not na(bot_max)
    contatore_media += 1 
    media := media + ((top_max - bot_max) / 2)
//
var float piv_distance                = input.float(title='Distanza di prezzo per posizioni cover', defval=50, minval=1)
var float piv_distance_1                  = na 
var float piv_distance_2                  = na 
var float piv_distance_3                  = na 
var float piv_distance_1_res              = na 
var float piv_distance_2_res              = na 
var float piv_distance_3_res              = na 

if barstate.islastconfirmedhistory
    media_mom := media / contatore_media
    media_vol := math.max(media_mom, min_0_3)
    piv_distance := media_vol
    piv_distance_1                  := piv_distance   * incremento_distanza_pivot
    piv_distance_2                  := piv_distance_1 * incremento_distanza_pivot
    piv_distance_3                  := piv_distance_2 * incremento_distanza_pivot
    piv_distance_1_res              := piv_distance   * incremento_resistenze_pivot
    piv_distance_2_res              := piv_distance_1_res * incremento_resistenze_pivot
    piv_distance_3_res              := piv_distance_2_res * incremento_resistenze_pivot
//

//Questa struttura serve per ancora la bbars al pivot quando il codice è startato in run == 1 
var float bot_mom = na 
var float top_mom = na 
var bool bar_reach = false 
var int contatore_try = na 

if tot_position[1] == 0
    //Questo è lo start del codice oltre che lo switch di pivot, tendenzilmente vengono cercati prima i supporti chiave e poi eventuali resistenze che indicano cadute, questa scelta è stata operata per attendere un certo numero di candele prima di switchare il pivot evitando di perdere i volumi della caduta precedente.
    if ((run == 0 and barstate.islastconfirmedhistory) or bar_reach[1]) and ancoraggio_pivot and ((bar_index - support_switch_bar - 1)) < bar_limit and ((bar_index - support_switch_bar - original_bbars)) > 0 and actual_supporto <= bot
        contatore_try := bar_index - original_bbars - support_switch_bar
        top_mom := 0
        bot_mom := 9999999 
        for i = 1 to (bbars + contatore_try) //Eseguo un mini test rapido ad ogni switch per assisurarmi di non avere schiacciamenti di volume, lo switch a livello grafico causa spesso crash del codice, tuttavia a livello di alert funzona anche a 1s perchè vengono eliminati automaticamente i sistemi di plottaggio del codice (non serve mettere showplot false per farlo funzionare)
            if high[i] > top_mom
                top_mom := high[i]
            if low[i] < bot_mom 
                bot_mom := low[i] 
        actual_media_vol := top_mom - bot_mom
        if actual_media_vol > media_vol 
            contatore := bar_index - original_bbars - support_switch_bar
            block_start_bar := true 
            bot_block_fast := true
        //
    //
    if ((run == 0 and barstate.islastconfirmedhistory) or bar_reach[1]) and not bot_block_fast and ancoraggio_pivot and ((bar_index - res_switch_bar - 1)) < bar_limit and ((bar_index - res_switch_bar - original_bbars)) > 0 and not bot_block
        contatore_try := bar_index - original_bbars - res_switch_bar
        top_mom := 0
        bot_mom := 9999999 
        for i = 1 to (bbars + contatore_try) 
            if high[i] > top_mom
                top_mom := high[i]
            if low[i] < bot_mom 
                bot_mom := low[i] 
        actual_media_vol := top_mom - bot_mom
        if actual_media_vol > media_vol 
            contatore := bar_index - original_bbars - res_switch_bar
            block_start_bar := true 
            top_block_fast := true 

    //
    if ((run == 0 and barstate.islastconfirmedhistory) or bar_reach[1]) and not top_block_fast and ancoraggio_pivot and ((bar_index - support_switch_bar_old - 1)) < bar_limit and ((bar_index - support_switch_bar_old - original_bbars)) > 0 
        contatore_try := bar_index - original_bbars - support_switch_bar_old
        top_mom := 0
        bot_mom := 9999999 
        for i = 1 to (bbars + contatore_try)
            if high[i] > top_mom
                top_mom := high[i]
            if low[i] < bot_mom 
                bot_mom := low[i] 
        actual_media_vol := top_mom - bot_mom
        if actual_media_vol > media_vol 
            contatore := bar_index - original_bbars - support_switch_bar_old
            block_start_bar := true 
            bot_block := true
            bot_block_fast := false 
        //


    if ((run == 0 and barstate.islastconfirmedhistory or bar_reach[1])) and not bot_block and ancoraggio_pivot and ((bar_index - res_switch_bar_old - 1)) < bar_limit and ((bar_index - res_switch_bar_old - original_bbars)) > 0 
        contatore_try := bar_index - original_bbars - res_switch_bar_old
        block_start_bar := true 
        top_block := true
        top_mom := 0
        bot_mom := 9999999 
        for i = 1 to (bbars + contatore_try) 
            if high[i] > top_mom
                top_mom := high[i]
            if low[i] < bot_mom 
                bot_mom := low[i] 
        actual_media_vol := top_mom - bot_mom
        if actual_media_vol > media_vol 
            contatore := bar_index - original_bbars - res_switch_bar_old
            block_start_bar := true 
            top_block := true
            top_block_fast := false 
    //

if block_start_bar
    bbars := bbars + contatore
    if run == 0 or (bbars < bbars[1]) //Ho dovuto calcolare manualmente top e bot durante lo switch, la funzione ta.pivot continuava a creare problemi utilizzando una lenght mobile
        top := 0
        bot := 9999999 
        for i = 1 to bbars 
            if high[i] > top
                top := high[i]
            if low[i] < bot 
                bot := low[i] 
        if (bbars < bbars[1])
            save_bot_liq := na 
            save_top_liq := na 
//

bar_reach := bbars == bar_limit

if bar_reach //Azzero le bool di ricerca prima dello switch
    bot_block      := false
    top_block      := false
    bot_block_fast := false
    top_block_fast := false
//

//Distanza delle posizioni cover

if run == 0 and not block_start_bar
    bot := bot_max
    top := top_max
if (not block_start_bar)
    bot := bot_max
    top := top_max

// iterazione anticipata per breakout in modo da abbreviare il numero di calcoli
// Dichiarazione delle variabili per i breakout
var float old_top = na 
var float old_bot = na

if high > top
    top := high
    if not up_breakout
        up_breakout := true 
        bot_in_up_break_out := bot
        distanza_break_out_up := top[1] - bot_in_up_break_out
//
if low < bot 
    bot := low 
    if not down_breakout
        down_breakout := true 
        top_in_down_break_out := top
        distanza_break_out_down := top_in_down_break_out - bot[1]
//

// ----------------------------------------}

// Gestione cover
// -----------------------------------------------------------{

//Assegnazioni di pivot distanti per posizioni cover
var float old_sup   = na
var float old_sup_1 = na
var float old_sup_2 = na
var float old_sup_3 = na
var float old_res   = na
var float old_res_1 = na
var float old_res_2 = na 
var float old_res_3 = na 
var int tot_sup     = na 
var int tot_res     = na 

//Iterazione scalare per il sistema cover
if barstate.islastconfirmedhistory and array.size(a_sup) > 0
    tot_sup := 0 
    
    array.sort(a_sup, order.descending)  // Ordine decrescente per supporti
    // Trova il primo supporto <= actual_supporto
    for i = 0 to array.size(a_sup) - 1
        if fast_play and block_start_bar 
            if array.get(a_sup, i) < bot - piv_distance
                old_sup := array.get(a_sup, i)
                if not na(old_sup)
                    tot_sup += 1
                break
    for i = 0 to array.size(a_sup) - 1
        if fast_play and not block_start_bar
            if array.get(a_sup, i) < bot
                old_sup := array.get(a_sup, i)
                if not na(old_sup)
                    tot_sup += 1
                break
    //
    for i = 0 to array.size(a_sup) - 1
        if not fast_play 
            if array.get(a_sup, i) < actual_supporto - piv_distance 
                old_sup := array.get(a_sup, i)
                if not na(old_sup)
                    tot_sup += 1
                break
    //
    //
    if not na(old_sup)
        for i = 0 to array.size(a_sup) - 1
            if array.get(a_sup, i) < old_sup - piv_distance_1
                old_sup_1 := array.get(a_sup, i)
                if not na(old_sup_1)
                    tot_sup += 1
                break
    if not na(old_sup_1)
        for i = 0 to array.size(a_sup) - 1
            if array.get(a_sup, i) < old_sup_1 - piv_distance_2
                old_sup_2 := array.get(a_sup, i)
                if not na(old_sup_2)
                    tot_sup += 1
                break
    if not na(old_sup_2)
        for i = 0 to array.size(a_sup) - 1
            if array.get(a_sup, i) < old_sup_2 - piv_distance_3
                old_sup_3 := array.get(a_sup, i)
                if not na(old_sup_3)
                    tot_sup += 1
                break
    // 
if barstate.islastconfirmedhistory and array.size(a_sup) > 0
    tot_res := 0 
    
    array.sort(a_sup, order.ascending) // Ordine crescente per resistenze
    // Trova la prima resistenza >= actual_resistenza
    for i = 0 to array.size(a_sup) - 1
        if fast_play 
            if array.get(a_sup, i) > top + piv_distance and block_start_bar
                old_res := array.get(a_sup, i)
                if not na(old_res)
                    tot_res += 1 
                break
            if array.get(a_sup, i) > top and not block_start_bar
                old_res := array.get(a_sup, i)
                if not na(old_res)
                    tot_res += 1
                break
    for i = 0 to array.size(a_sup) - 1
        if not fast_play 
            if array.get(a_sup, i) > actual_resistenza + piv_distance 
                old_res := array.get(a_sup, i)
                if not na(old_res)
                    tot_res += 1 
                break
    if not na(old_res)
        for i = 0 to array.size(a_sup) - 1
            if array.get(a_sup, i) > old_res + piv_distance_1_res
                old_res_1 := array.get(a_sup, i)
                if not na(old_res_1)
                    tot_res += 1 
                break
    if not na(old_res_1)
        for i = 0 to array.size(a_sup) - 1
            if array.get(a_sup, i) > old_res_1 + piv_distance_2_res
                old_res_2 := array.get(a_sup, i)
                if not na(old_res_2)
                    tot_res += 1 
                break
    if not na(old_res_2)
        for i = 0 to array.size(a_sup) - 1
            if array.get(a_sup, i) > old_res_2 + piv_distance_3_res
                old_res_3 := array.get(a_sup, i)
                if not na(old_res_3)
                    tot_res += 1 
                break
    //
// ----------------------------------------}

//Gestione corrispondenze pivot - bot/top
// -----------------------------------------------------------{

// Tabella per assegnazioni strategie 
var int actual_support_over_bot_perc = 0

bot_is_sup := (bot == actual_supporto or bot == actual_old_supporto) ? true : false 
top_is_res := (top == actual_resistenza or top == actual_old_resistenza) ? true : false 

bot_is_sup_started = bot_is_sup and not bot_is_sup[1]
top_is_res_started = top_is_res and not top_is_res[1]

bot_is_sup_over    = not bot_is_sup and bot_is_sup[1]
top_is_res_over    = not top_is_res and top_is_res[1]

if bot_is_sup and actual_supporto > bot
    actual_support_over_bot_perc := math.round(((actual_supporto - bot) / (top - bot)) * 100) 
//
if not bot_is_sup
    actual_support_over_bot_perc := 0
//

// ----------------------------------------}

// ----------------------------------------}

// TV e break
// -----------------------------------------------------------{

// Dichiarazioni Volume indicator + dichiarazioni liq
// -----------------------------------------------------------{

var int cnum = current_timeframe == "1S" ? 50 : 100 // in quante righe suddividere le barre del volume profile

global_distance = top - bot //Calcolo la distanza globale per preparare un banale sistema di proporzioni e trasformare in percentuale i dati, questo aiuta a triggerare più facilmente i valori che si avvicinano al target predefinito
step = global_distance / cnum

var int poc_width = 1
var int vah_width = 1
var int val_width = 1
var int ext_width = 1

// Identifica i pivot high e low brevi per impostare la liquidità attuale 
pivot_high = ta.pivothigh(high, 1, 1)
pivot_low  = ta.pivotlow(low, 1, 1)

// Array per memorizzare i pivot rilevati e i loro timestamp
var float[] high_pivots     = array.new_float(0)
var float[] low_pivots      = array.new_float(0)
var int[] high_bar_indices  = array.new_int(0)  // Memorizza l'indice della barra quando il pivot è stato aggiunto
var int[] low_bar_indices   = array.new_int(0)   // Memorizza l'indice della barra quando il pivot è stato aggiunto

// Aggiungi un nuovo pivot high quando trovato
if not na(pivot_high) 
    array.push(high_pivots, pivot_high)
    array.push(high_bar_indices, bar_index)
//    
// Aggiungi un nuovo pivot low quando trovato
if not na(pivot_low) 
    array.push(low_pivots, pivot_low)
    array.push(low_bar_indices, bar_index)
//    

// Rimuovi i pivot più vecchi di bbars
int current_bar = bar_index

// Rimuovi i pivot high più vecchi di bbars
if array.size(high_bar_indices) > 0
    while array.size(high_bar_indices) > 0 and (current_bar - array.get(high_bar_indices, 0)) == bar_limit +1
        array.shift(high_pivots)
        array.shift(high_bar_indices)
//    
// Rimuovi i pivot low più vecchi di bbars
if array.size(low_bar_indices) > 0
    while array.size(low_bar_indices) > 0  and (current_bar - array.get(low_bar_indices, 0))  == bar_limit +1
        array.shift(low_pivots)
        array.shift(low_bar_indices)
//    
// Trova il pivothigh più basso e il pivotlow più alto, se gli array non sono vuoti
// Per bot_liq: trovare il minimo pivot high all'interno dell'intervallo bbars
if na(save_bot_liq)
    bot_liq := na
    if array.size(high_pivots) > 0
        // Trovo i pivot high all'interno dell'intervallo bbars
        float[] valid_high_pivots = array.new_float(0)
        for i = 0 to array.size(high_pivots) - 1
            if (current_bar - array.get(high_bar_indices, i)) < bbars
                array.push(valid_high_pivots, array.get(high_pivots, i))
        
        // Se ci sono pivot high validi, prendo il minimo
        if array.size(valid_high_pivots) > 0
            bot_liq := array.min(valid_high_pivots)
    //
// Per top_liq: trovare il massimo pivot low all'interno dell'intervallo bbars
if na(save_top_liq)
    top_liq := na
    if array.size(low_pivots) > 0
        // Trovo i pivot low all'interno dell'intervallo bbars
        float[] valid_low_pivots = array.new_float(0)
        for i = 0 to array.size(low_pivots) - 1
            if (current_bar - array.get(low_bar_indices, i)) < bbars
                array.push(valid_low_pivots, array.get(low_pivots, i))
        
        // Se ci sono pivot low validi, prendo il massimo
        if array.size(valid_low_pivots) > 0
            top_liq := array.max(valid_low_pivots)
        //
if not na(save_bot_liq)
    bot_liq := save_bot_liq
if not na(save_top_liq)
    top_liq := save_top_liq
//

// ----------------------------------------}

// VAR generali dichiarazioni dell'analisi del volume
// ------------------------------------------------------------{

var float poc_level = na
var float vah_level = na
var float val_level = na
var float poc_bot_level = na
var float poc_top_level = na
var color poc_color = na
var float break_out_up_perc_mom = na 
var float break_out_down_perc_mom = na 
var float vol_distance_perc = na 
 
var int vah_perc     = na //Le perc servono per iterare più facilmente i trig perchè utilizzando l'arrotondamento riesco a recuperare valoci vicini alle linee di trig
var int poc_perc     = na //Le perc servono per iterare più facilmente i trig perchè utilizzando l'arrotondamento riesco a recuperare valoci vicini alle linee di trig
var int poc_2_perc   = na //Le perc servono per iterare più facilmente i trig perchè utilizzando l'arrotondamento riesco a recuperare valoci vicini alle linee di trig
var int val_perc     = na //Le perc servono per iterare più facilmente i trig perchè utilizzando l'arrotondamento riesco a recuperare valoci vicini alle linee di trig
var int bot_liq_perc = na //Le perc servono per iterare più facilmente i trig perchè utilizzando l'arrotondamento riesco a recuperare valoci vicini alle linee di trig
var int top_liq_perc = na //Le perc servono per iterare più facilmente i trig perchè utilizzando l'arrotondamento riesco a recuperare valoci vicini alle linee di trig

float[] totalvols = array.new_float(cnum, 0.)
var float vol_value = na 

var float val_to_bot_volume_perc = na  // Percentuale di volume tra val e bot
var float vah_to_top_volume_perc = na  // Percentuale di volume tra vah e top
var float central_volume_perc = na  

var bool poc_is_buy = false //Definisce lo stato attuale del poc 
var int low_perc = na 
var int high_perc = na 
var float poc_second_level = na
var color poc_2_color = na 

// Draw lines
var line poc_line           = na
var line poc_2_line         = na
var line top_line           = na
var line bot_line           = na
var line upper_line         = na
var line lower_line         = na
var line lower_line_liq     = na
var line higher_line_liq    = na
var line poc_bot_level_line = na
var line poc_top_level_line = na
var line res_line           = na 
var line sup_line           = na 
var line res_line_1         = na 
var line sup_line_1         = na 
var line res_line_2         = na 
var line sup_line_2         = na 
var line res_line_3         = na 
var line sup_line_3         = na 
// Draw VP rows
var vol_bars = array.new_box(cnum * 2, na)

// ----------------------------------------}

// Volume indicator
// ------------------------------------------------------------{

levels = array.new_float(cnum + 1)
for x = 0 to cnum by 1
    array.set(levels, x, bot + step * x)
//
// get the volume if there is intersection
get_vol(y11, y12, y21, y22, height, vol) =>
    nz(math.max(math.min(math.max(y11, y12), math.max(y21, y22)) - math.max(math.min(y11, y12), math.min(y21, y22)), 0) * vol / height)
//
var float vah_to_poc_vol_ratio = na
var float poc_2_to_poc_vol_ratio = na
var float val_to_poc_vol_ratio = na
//L'indicare volume profile seguente è particolare in quanto raddoppia il peso delle spike rispetto al peso dei corpi in modo da avvicinarsi il più possibile al corretto livello di poc
if (barstate.isconfirmed and run > 0 ) or (run == 0 and barstate.islastconfirmedhistory)
    if run < 2 
        if run == 1
            alert("Run",alert.freq_once_per_bar)
        run += 1
    // calculate/get volume for each channel and candle
    volumes = array.new_float(cnum * 2, 0.)
    for bars = 0 to bbars - 1 by 1
        body_top = math.max(close[bars], open[bars])
        body_bot = math.min(close[bars], open[bars])
        itsgreen = close[bars] >= open[bars]

        topwick     = high[bars] - body_top
        bottomwick  = body_bot - low[bars]
        body        = body_top - body_bot

        bodyvol         = body * volume[bars]           / (2 * topwick + 2 * bottomwick + body)
        topwickvol      = 2 * topwick * volume[bars]    / (2 * topwick + 2 * bottomwick + body)
        bottomwickvol   = 2 * bottomwick * volume[bars] / (2 * topwick + 2 * bottomwick + body)
        for x = 0 to cnum - 1 by 1
            array.set(volumes, x, array.get(volumes, x) + (itsgreen ? get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, body_top, body, bodyvol) : 0) + get_vol(array.get(levels, x), array.get(levels, x + 1), body_top, high[bars], topwick, topwickvol) / 2 + get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, low[bars], bottomwick, bottomwickvol) / 2)
            array.set(volumes, x + cnum, array.get(volumes, x + cnum) + (itsgreen ? 0 : get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, body_top, body, bodyvol)) + get_vol(array.get(levels, x), array.get(levels, x + 1), body_top, high[bars], topwick, topwickvol) / 2 + get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, low[bars], bottomwick, bottomwickvol) / 2)
    //
    totalvols := array.new_float(cnum, 0.)
    for x = 0 to cnum - 1 by 1
        array.set(totalvols, x, array.get(volumes, x) + array.get(volumes, x + cnum))
    //
    int poc = array.indexof(totalvols, array.max(totalvols))

    // calculate value area
    totalmax = array.sum(totalvols) * percent / 100.
    va_total = array.get(totalvols, poc)
    int up = poc
    int down = poc
    for x = 0 to cnum - 1 by 1
        if va_total >= totalmax
            break
        uppervol = up < cnum - 1 ? array.get(totalvols, up + 1) : 0.
        lowervol = down > 0      ? array.get(totalvols, down - 1) : 0.
        if uppervol == 0 and lowervol == 0
            break
        if uppervol >= lowervol
            va_total += uppervol
            up += 1
            up
        else
            va_total += lowervol
            down -= 1
            down
    //
    // Sposto le liquiditù sulle assenze di volume per non perdere le inefficienze di apertura di mercato

    float new_bot_liq = bot_liq
    
    // Trova l'indice di livello corrispondente a bot_liq
    int bot_liq_index = 0
    for i = 0 to cnum - 1
        if array.get(levels, i) <= bot_liq and (i == cnum - 1 or array.get(levels, i + 1) > bot_liq)
            bot_liq_index := i
            break
    
    // Controlla le barre dall'alto verso il basso per trovare volume assente
    for i = bot_liq_index to 0
        if i < array.size(totalvols)
            if array.get(totalvols, i) == 0
                // Trovata barra con volume assente, aggiorna bot_liq
                new_bot_liq := array.get(levels, i)
                bot_liq_modified := true
                break
    
    // Aggiorna bot_liq se necessario
    if bot_liq_modified
        bot_liq := new_bot_liq
    //
    float new_top_liq = top_liq
    
    // Trova l'indice di livello corrispondente a top_liq
    int top_liq_index = cnum - 1
    for i = 0 to cnum - 1
        if array.get(levels, i) <= top_liq and (i == cnum - 1 or array.get(levels, i + 1) > top_liq)
            top_liq_index := i
            break
    
    // Controlla le barre dal basso verso l'alto per trovare volume assente
    for i = top_liq_index to cnum - 1
        if i < array.size(totalvols)
            if array.get(totalvols, i) == 0
                // Trovata barra con volume assente, aggiorna top_liq
                new_top_liq := array.get(levels, i)
                top_liq_modified := true
                break
    
    // Aggiorna top_liq se necessario
    if top_liq_modified
        top_liq := new_top_liq

    // Ottimizzazione migliorata del livello VAH - SOLO VERSO L'ALTO ricerco livelli con ratio maggiore a quello attuale 
    int original_up = up
    bool vah_moved = false

    // Iterazione verso l'alto
    int current_level = original_up
    float current_max_vol = array.get(totalvols, current_level)
    int max_vol_level = current_level

    // Verifica se esiste un livello superiore e cerca livelli con volume maggiore
    while current_level + 1 < cnum
        current_level += 1
        float next_vol = array.get(totalvols, current_level)
        
        // Se il volume del livello superiore è maggiore, aggiorna il massimo
        if next_vol > current_max_vol
            current_max_vol := next_vol
            max_vol_level := current_level
            vah_moved := true
        else
            // Se troviamo un volume inferiore, interrompiamo
            break

    // Aggiorna il valore di up con il livello di massimo volume trovato
    up := max_vol_level

    // Ottimizzazione migliorata del livello VAL - SOLO VERSO IL BASSO ricerco livelli con ratio maggiore a quello attuale 
    int original_down = down
    bool val_moved = false

    // Iterazione verso il basso
    current_level := original_down
    current_max_vol := array.get(totalvols, current_level)
    max_vol_level := current_level

    // Verifica se esiste un livello inferiore
    while current_level > 0
        current_level -= 1
        float next_vol = array.get(totalvols, current_level)
        
        // Se il volume del livello inferiore è maggiore, aggiorna il massimo
        if next_vol > current_max_vol
            current_max_vol := next_vol
            max_vol_level := current_level
            val_moved := true
        else
            // Se troviamo un volume inferiore, interrompiamo
            break

    // Aggiorna il valore di down con il livello di massimo volume trovato
    down := max_vol_level

    // Solo dopo l'ottimizzazione, ricalcola i livelli VAH e VAL
    vah_level := up < cnum - 1 ? (array.get(levels, up) + array.get(levels, up + 1)) / 2 : array.get(levels, up)
    val_level := down > 0 ? (array.get(levels, down) + array.get(levels, down + 1)) / 2 : array.get(levels, down)
    poc_level := (array.get(levels, poc) + array.get(levels, poc + 1)) / 2

    // Trova il POC più grande al di fuori dell'area di valore
    float ext_poc_vol = 0
    int levels_size = array.size(levels)
    int totalvols_size = array.size(totalvols)

    // Variabile temporanea per memorizzare il risultato
    float temp_poc_second_level = na

    // Cerca sotto VAL (sicuro)
    if down > 0  // Verifica che ci siano livelli sotto VAL
        for i = 0 to math.min(down - 1, totalvols_size - 1)
            if i + 1 < levels_size  // Controlla che i+1 sia un indice valido per levels
                float vol = array.get(totalvols, i)
                if vol > ext_poc_vol
                    ext_poc_vol := vol
                    temp_poc_second_level := (array.get(levels, i) + array.get(levels, i + 1)) / 2

    // Cerca sopra VAH (sicuro)
    if up + 1 < totalvols_size  // Verifica che ci siano livelli sopra VAH
        int start_i = up + 1
        int end_i = totalvols_size - 1
        
        // Solo se start_i <= end_i, esegui il ciclo
        if start_i <= end_i
            for i = start_i to end_i
                if i + 1 < levels_size  // Controlla che i+1 sia un indice valido per levels
                    float vol = array.get(totalvols, i)
                    if vol > ext_poc_vol
                        ext_poc_vol := vol
                        temp_poc_second_level := (array.get(levels, i) + array.get(levels, i + 1)) / 2

    // Assegna il risultato solo se abbiamo trovato un valore valido
    if not na(temp_poc_second_level)
        poc_second_level := temp_poc_second_level    // Determina se il POC è rialzista o ribassista basandosi sul volume
    float poc_buy_volume = array.get(volumes, poc)
    float poc_sell_volume = array.get(volumes, poc + cnum)

    if poc_buy_volume > poc_sell_volume
        poc_color := color.blue  // Maggior volume di acquisto
        poc_is_buy := true 
    else if poc_sell_volume > poc_buy_volume
        poc_color := color.red // Maggior volume di vendita
        poc_is_buy := false 

    // Trova l'indice che corrisponde a val_level
    int val_index = down
    // Trova l'indice che corrisponde a top (ultimo elemento dell'array levels)
    int top_index = cnum - 1
    // L'indice che corrisponde a bot è 0

    // Versione robusta per il calcolo del volume tra val_level e bot
    float val_to_bot_volume = 0.0
    if val_index >= 0  // Controlla che val_index sia valido
        for i = 0 to math.min(val_index, cnum - 1)  // Limita l'indice superiore
            val_to_bot_volume += array.get(totalvols, i)

    // Versione robusta per il calcolo del volume tra vah_level e top
    float vah_to_top_volume = 0.0
    if up + 1 < cnum and top_index >= 0  // Controlla validità di entrambi gli indici
        for i = math.max(0, up + 1) to math.min(top_index, cnum - 1)  // Limita entrambi gli indici
            vah_to_top_volume += array.get(totalvols, i)

    // Calcolo del volume totale rimane invariato
    float total_volume = array.sum(totalvols)
    // Calcola le percentuali rispetto al volume totale
    val_to_bot_volume_perc := (val_to_bot_volume / total_volume) * 100
    vah_to_top_volume_perc := (vah_to_top_volume / total_volume) * 100
    central_volume_perc := 100 - val_to_bot_volume_perc - vah_to_top_volume_perc
//

// Calcolo delle percentuali di volume rispetto al POC
    // -----------------------------------------------------------{

    // Calcola solo dopo che il profilo volumetrico è stato completato
    if run > 0 and barstate.isconfirmed
        // Trova l'indice che corrisponde al POC
        int poc_index = array.indexof(totalvols, array.max(totalvols))
        
        // Trova l'indice che corrisponde al VAH
        int vah_index = up
        
        // Trova l'indice che corrisponde al POC_2
        // Calcola la distanza tra POC e POC_2 per determinare l'indice
        float poc_to_poc_2_distance = math.abs(poc_level - poc_second_level)
        int poc_2_index = -1
        
        // Determina l'indice di POC_2 cercando il livello più vicino
        if not na(poc_second_level)
            float min_distance = 999999.0
            for i = 0 to cnum - 1
                float level_mid = (array.get(levels, i) + array.get(levels, i + 1)) / 2
                float distance = math.abs(level_mid - poc_second_level)
                if distance < min_distance
                    min_distance := distance
                    poc_2_index := i
        
        // Calcola i rapporti di volume solo se gli indici sono validi
        if poc_index >= 0 and vah_index >= 0
            float poc_volume = array.get(totalvols, poc_index)
            
            if poc_volume > 0
                // Calcola il rapporto tra il volume al VAH e il volume al POC
                float vah_volume = array.get(totalvols, vah_index)
                vah_to_poc_vol_ratio := (vah_volume / poc_volume) * 100
                
                // Calcola il rapporto tra il volume al POC_2 e il volume al POC
                if poc_2_index >= 0
                    float poc_2_volume = array.get(totalvols, poc_2_index)
                    poc_2_to_poc_vol_ratio := (poc_2_volume / poc_volume) * 100
                    
                // Calcola il rapporto tra il volume al VAL e il volume al POC
                if val_index >= 0
                    float val_volume = array.get(totalvols, val_index)
                    val_to_poc_vol_ratio := (val_volume / poc_volume) * 100

    // -------------------------------------}
// -------------------------------------}

// Definizione label - line e valori top/bot delle linee di poc - val e vah
// ------------------------------------------------------------{

    mid_distance = global_distance / 2

    poc_bot_level := bot + mid_distance 

    vah_perc        := math.round(((vah_level - bot) / global_distance) * 100)
    poc_perc        := math.round(((poc_level - bot) / global_distance) * 100)
    poc_2_perc      := math.round(((poc_second_level - bot) / global_distance) * 100)
    val_perc        := math.round(((val_level - bot) / global_distance) * 100)
    bot_liq_perc    := math.round(((bot_liq - bot) / global_distance) * 100)
    top_liq_perc    := math.round(((top_liq - bot) / global_distance) * 100)
    low_perc        := math.floor(((low - bot) / global_distance) * 100)
    high_perc       := math.ceil(((high - bot) / global_distance) * 100)

    vol_distance         = vah_level - val_level
    vol_distance_perc   := vah_perc - val_perc
    vol_value           := vah_level - val_level
    //

//Riadattamento di posizioni cover (aggiunto successivamente per recuperare media del volume corretta per distanziare le posizioni switch_resistenza//Riordino supporti e resistenze quando viene impostato un nuovo pivot e quel pivot corrisponde a sup/res attuale)
// -----------------------------------------------------------{

    piv_distance_1 := piv_distance   * incremento_distanza_pivot
    piv_distance_2 := piv_distance_1 * incremento_distanza_pivot
    piv_distance_3 := piv_distance_2 * incremento_distanza_pivot

    //Gestione del sistema cover dopo l'iterazione run == 0 che definisce i punti di start, potrebbe essere spostato sopra questo blocco, al momento si trova qua perchè le posizioni cover erano precedentemente ancorate alla distanza VAL VAH che però portava a delle sovracompressioni in timeframe brevi, in realtà a timeframe alti era in grado di velocizzare la gestione a timeframe alti e non scarterei a priori questa opzione.
    if run > 0 and bot != bot[1] and array.size(a_sup) > 0
        tot_sup := 0 
        //
        array.sort(a_sup, order.descending)  // Ordine decrescente per supporti
        // Trova il primo supporto <= actual_supporto
        for i = 0 to array.size(a_sup) - 1
            if fast_play and bot_is_sup
                if array.get(a_sup, i) < bot - piv_distance
                    old_sup := array.get(a_sup, i)
                    if not na(old_sup)
                        tot_sup += 1
                    break
        for i = 0 to array.size(a_sup) - 1
            if fast_play and not bot_is_sup
                if actual_supporto < bot and not bot_is_sup
                    if array.get(a_sup, i) < bot
                        old_sup := array.get(a_sup, i)
                        if not na(old_sup)
                            tot_sup += 1
                        break
        //
        for i = 0 to array.size(a_sup) - 1
            if not fast_play 
                if array.get(a_sup, i) < actual_supporto - piv_distance 
                    old_sup := array.get(a_sup, i)
                    if not na(old_sup)
                        tot_sup += 1
                    break
        //
        if not na(old_sup)
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) < old_sup - piv_distance_1
                    old_sup_1 := array.get(a_sup, i)
                    if not na(old_sup_1)
                        tot_sup += 1
                    break
        if not na(old_sup_1) 
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) < old_sup_1 - piv_distance_2
                    old_sup_2 := array.get(a_sup, i)
                    if not na(old_sup_2)
                        tot_sup += 1
                    break
        if not na(old_sup_2)
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) < old_sup_2 - piv_distance_3
                    old_sup_3 := array.get(a_sup, i)
                    if not na(old_sup_3)
                        tot_sup += 1
                    break
        //
    if run > 0 and top != top[1] and array.size(a_sup) > 0
        tot_res := 0 
        //
        array.sort(a_sup, order.ascending) // Ordine crescente per resistenze
        
        // Trova la prima resistenza >= actual_resistenza
        for i = 0 to array.size(a_sup) - 1
            if fast_play 
                if array.get(a_sup, i) > top + piv_distance and block_start_bar
                    old_res := array.get(a_sup, i)
                    if not na(old_res)
                        tot_res += 1 
                    break
                if array.get(a_sup, i) > top and not block_start_bar
                    old_res := array.get(a_sup, i)
                    if not na(old_res)
                        tot_res += 1
                    break
        for i = 0 to array.size(a_sup) - 1
            if not fast_play 
                if array.get(a_sup, i) > actual_resistenza + piv_distance 
                    old_res := array.get(a_sup, i)
                    if not na(old_res)
                        tot_res += 1 
                    break
        //     
        if not na(old_res)
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) > old_res + piv_distance_1_res
                    old_res_1 := array.get(a_sup, i)
                    if not na(old_res_1)
                        tot_res += 1 
                    break
        if not na(old_res_1)
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) > old_res_1 + piv_distance_2_res
                    old_res_2 := array.get(a_sup, i)
                    if not na(old_res_2)
                        tot_res += 1 
                    break
        if not na(old_res_2)
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) > old_res_2 + piv_distance_3_res
                    old_res_3 := array.get(a_sup, i)
                    if not na(old_res_3)
                        tot_res += 1 
                    break
    //

// -------------------------------------}
    //Sistema generale di plot 
    if run > 1 and not show_plot
        line.delete(poc_line)
        line.delete(poc_2_line)
        line.delete(top_line)
        line.delete(bot_line)
        line.delete(upper_line)
        line.delete(lower_line)
        line.delete(lower_line_liq)
        line.delete(higher_line_liq)
        line.delete(poc_bot_level_line)
        line.delete(poc_top_level_line)
        line.delete(res_line)
        line.delete(sup_line)
        line.delete(res_line_1)
        line.delete(sup_line_1)
        line.delete(res_line_2)
        line.delete(sup_line_2)
        line.delete(res_line_3)
        line.delete(sup_line_3)
    //
    if show_plot or run == 0 or run == 1 

        line.delete(poc_line)
        line.delete(poc_2_line)
        line.delete(top_line)
        line.delete(bot_line)
        line.delete(upper_line)
        line.delete(lower_line)
        line.delete(lower_line_liq)
        line.delete(higher_line_liq)
        line.delete(poc_bot_level_line)
        line.delete(poc_top_level_line)
        line.delete(res_line)
        line.delete(sup_line)
        line.delete(res_line_1)
        line.delete(sup_line_1)
        line.delete(res_line_2)
        line.delete(sup_line_2)
        line.delete(res_line_3)
        line.delete(sup_line_3)

        if high_perc == vah_perc or low_perc == vah_perc
            vah_color := positiveColor
        else
            vah_color := negativeColor
        //
        if high_perc == val_perc or low_perc == val_perc
            val_color := positiveColor
        else
            val_color := negativeColor
        //
        poc_2_color := poc_level > poc_second_level ? color.red : color.blue
        // Disegna le linee
        poc_line        := line.new(bar_index - bbars, poc_level,  bar_index + 13, poc_level,   color=poc_color,     width=poc_width, force_overlay = true)    
        poc_2_line      := line.new(bar_index - bbars, poc_second_level,  bar_index + 13, poc_second_level,   color=poc_2_color,     width=poc_width, force_overlay = true)    
        top_line        := line.new(bar_index - bbars, top,        bar_index + 13, top,         color=negativeColor,   width=ext_width, force_overlay = true)    
        bot_line        := line.new(bar_index - bbars, bot,        bar_index + 13, bot,         color=bot_is_sup ? positiveColor : negativeColor, width=ext_width, force_overlay = true)    
        upper_line      := line.new(bar_index - bbars, vah_level,  bar_index + 13, vah_level,   color=color.white, width=vah_width, force_overlay = true)
        lower_line      := line.new(bar_index - bbars, val_level,  bar_index + 13, val_level,   color=color.white, width=val_width, force_overlay = true)
        lower_line_liq  := line.new(bar_index - bbars, bot_liq,    bar_index + 13, bot_liq,     color=color.green, width=val_width, force_overlay = true)
        higher_line_liq := line.new(bar_index - bbars, top_liq,    bar_index + 13, top_liq,     color=color.red,   width=val_width, force_overlay = true)
        res_line        := line.new(bar_index - bbars, old_res,    bar_index + 13, old_res,     color=negativeColor,   width=2, force_overlay = true)
        sup_line        := line.new(bar_index - bbars, old_sup,    bar_index + 13, old_sup,     color=positiveColor, width=2, force_overlay = true)
        res_line_1      := line.new(bar_index - bbars, old_res_1,  bar_index + 13, old_res_1,   color=negativeColor,   width=2, force_overlay = true)
        sup_line_1      := line.new(bar_index - bbars, old_sup_1,  bar_index + 13, old_sup_1,   color=positiveColor, width=2, force_overlay = true)
        res_line_2      := line.new(bar_index - bbars, old_res_2,  bar_index + 13, old_res_2,   color=negativeColor,   width=2, force_overlay = true)
        sup_line_2      := line.new(bar_index - bbars, old_sup_2,  bar_index + 13, old_sup_2,   color=positiveColor, width=2, force_overlay = true)
        res_line_3      := line.new(bar_index - bbars, old_res_3,  bar_index + 13, old_res_3,   color=negativeColor,   width=2, force_overlay = true)
        sup_line_3      := line.new(bar_index - bbars, old_sup_3,  bar_index + 13, old_sup_3,   color=positiveColor, width=2, force_overlay = true)
        //
        
        dist = (top - bot) / 500
        if current_timeframe != "1S"
            var vup_color = positiveColor
            var vdown_color = negativeColor
            var up_color = color.new(color.green, 70)
            var down_color = color.new(color.red, 70)
        
            // Trova il volume massimo per la normalizzazione
            float max_vol = 0
            for i = 0 to cnum - 1
                max_vol := math.max(max_vol, array.get(volumes, i) + array.get(volumes, i + cnum))

            // Definisci la larghezza massima desiderata in barre
            int max_width = 50  // Puoi regolare questo valore secondo le tue preferenze

            for x = 0 to cnum - 1 by 1
                box.delete(array.get(vol_bars, x))
                box.delete(array.get(vol_bars, x + cnum))
                
                // Calcola la larghezza normalizzata per volumi rialzisti
                int bull_width = max_vol > 0 ? math.min(math.round(array.get(volumes, x) / max_vol * max_width), max_width) : 0
                
                // Disegna le barre rialziste
                array.set(vol_bars, x, box.new(bar_index + 13, 
                                             array.get(levels, x + 1) - dist, 
                                             bar_index + 13 + bull_width, 
                                             array.get(levels, x) + dist, 
                                             border_width=0, 
                                             bgcolor=x >= down and x <= up ? vup_color : up_color,
                                             force_overlay= true ))

                // Calcola la larghezza normalizzata per volumi ribassisti
                int bear_width = max_vol > 0 ? math.min(math.round(array.get(volumes, x + cnum) / max_vol * max_width), max_width) : 0

                // Disegna le barre ribassiste
                array.set(vol_bars, x + cnum, box.new(bar_index + 13 + bull_width, 
                                                     array.get(levels, x + 1) - dist, 
                                                     bar_index + 13 + bull_width + bear_width, 
                                                     array.get(levels, x) + dist, 
                                                     border_width=0, 
                                                     bgcolor=x >= down and x <= up ? vdown_color : down_color,
                                                     force_overlay= true))

// -------------------------------------}

// Calcolo Percentuali di Distanza e Break Out
// -----------------------------------------------------------{

// Inizializzazione dei breakout alla prima esecuzione, deve essere aggiustato, in questo momento rileva falsi break quando l'ancoraggio è avvenuto su supporto old o resistenza old 
if barstate.islastconfirmedhistory 
    if top > resistenza_old and low > poc_level
        old_top := resistenza_old
        up_breakout := true 
        bot_in_up_break_out := bot
        distanza_break_out_up := resistenza_old - bot_in_up_break_out
    //
    if bot < supporto_old and high < poc_level
        old_bot := supporto_old 
        down_breakout := true 
        top_in_down_break_out := top
        distanza_break_out_down := top_in_down_break_out - supporto_old
//

var float distanza_break_out_up_post = na 
var float break_out_up_perc = na 
var float break_out_up_top_perc = na 
var float break_out_down_perc = na 

// Una collezione per mantenere le label di breakout
var label[] saved_labels = array.new_label()
// Funzione per gestire la pulizia delle label
clean_labels() =>
    // Verifica se l'array supera il limite massimo (100 elementi)
    if array.size(saved_labels) > 100
        // Calcola quante label rimuovere (ad esempio, rimuovi le 20 più vecchie)
        labels_to_remove = 20
        
        // Rimuovi le label più vecchie (quelle all'inizio dell'array)
        for i = 0 to labels_to_remove - 1
            if array.size(saved_labels) > 0
                // Ottieni la label dall'array
                old_label = array.get(saved_labels, 0)
                // Elimina la label dalla chart
                label.delete(old_label)
                // Rimuovi la label dall'array
                array.remove(saved_labels, 0)
//Pulizia label in eccesso - al momento non veiene plottato questo array, la sua utilità è quella di vedere lo storico del grafico anche dopo che le bbars sono state superate. 
clean_labels() //blocco attualmente eliminabile - per rimuoverlo rimuovere tutte le label inserite nell'array

if run > 0
    breakout_bar_index_up = ta.valuewhen(high == top, bar_index, 0)

    if up_breakout and low < poc_level
        distanza_break_out_up_post  := top - bot_in_up_break_out
        break_out_up_perc           := ((distanza_break_out_up_post - distanza_break_out_up) / distanza_break_out_up) * 100
        up_breakout := false 

        // Crea la label e salvala nell'array
        label break_out_up_perc_label = label.new(
             breakout_bar_index_up, 
             top, 
             "Break_out: " + str.tostring(break_out_up_perc, "#.##") + "%", 
             color          =positiveColor, 
             style          =label.style_label_down, 
             textcolor      =color.white, 
             size           =size.small, 
             force_overlay  = true
             )
        array.push(saved_labels, break_out_up_perc_label)
    //
    var label vol_break_up_perc_mom_label = na
        
    label.delete(vol_break_up_perc_mom_label)

    var float distanza_break_out_post_mom_up = na 

    if up_breakout
        distanza_break_out_post_mom_up  := top - bot_in_up_break_out
        break_out_up_perc_mom           := ((distanza_break_out_post_mom_up - distanza_break_out_up) / distanza_break_out_up) * 100
        break_out_up_top_perc           := math.max(break_out_up_perc_mom, break_out_up_perc_mom[1])
        vol_break_up_perc_mom_label     := label.new(bar_index + 43 , top, 
                              text      = "Break: " + str.tostring(math.round_to_mintick(break_out_up_perc_mom)) + "%",
                              style     = label.style_label_down,
                              color     = na ,
                              textcolor = positiveColor, force_overlay = true)
    if not up_breakout and not na (break_out_up_top_perc)
        break_out_up_top_perc := na 
//

var float distanza_break_out_down_post = na 
var float break_out_down_top_perc = na 
var int breakout_bar_index_down = 0

// Una collezione per mantenere le label di breakout
if run > 0 
    breakout_bar_index_down := ta.valuewhen(low == bot, bar_index, 0)

    if down_breakout and high > poc_level
        distanza_break_out_down_post    := top_in_down_break_out - bot
        break_out_down_perc             := ((distanza_break_out_down_post - distanza_break_out_down) / distanza_break_out_down) * 100
        down_breakout := false 

        // Crea la label e salvala nell'array
        label break_out_down_perc_label = label.new(
             breakout_bar_index_down, 
             bot, 
             "Break_out: " + str.tostring(break_out_down_perc, "#.##") + "%", 
             color          =color.blue, 
             style          =label.style_label_up, 
             textcolor      =color.white, 
             size           =size.small, 
             force_overlay  = true
             )
        array.push(saved_labels, break_out_down_perc_label)
    //

    var label vol_break_down_perc_mom_label = na
        
    label.delete(vol_break_down_perc_mom_label)


    var float distanza_break_out_post_mom_down = na 
    if down_breakout
        distanza_break_out_post_mom_down    := top_in_down_break_out - bot
        break_out_down_perc_mom             := ((distanza_break_out_post_mom_down - distanza_break_out_down) / distanza_break_out_down) * 100
        break_out_down_top_perc             := math.max(break_out_down_perc_mom, break_out_down_perc_mom[1])
        vol_break_down_perc_mom_label       := label.new(bar_index + 43, bot, 
                              text          = "Break: " + str.tostring(math.round_to_mintick(break_out_down_perc_mom)) + "%",
                              style         = label.style_label_up,
                              color         = na ,
                              textcolor     = color.red, force_overlay = true)
    if not down_breakout and not na (break_out_down_top_perc)
        break_out_down_top_perc := na 
    //

// -------------------------------------}

// -------------------------------------}

// LR
// -----------------------------------------------------------{

//Utilizzo una lr per la gestione del trend, al momento risulta poco utilizzato rispetto alle sue reali potenzialità, il pearson è uno strumento fondamentale per la dinamizzazione dei flussi verso i rispettivi target
var float lr_vol_perc = na 

lengthInput_lr = bbars
sourceInput_lr = close

group1_lr = "Channel Settings"
useUpperDevInput_lr = true
var float upperMultInput_lr = 2
useLowerDevInput_lr = true
var float lowerMultInput_lr = 2

group2_lr = "Display Settings"
showPearsonInput_lr = true
extendLeftInput_lr = false
extendRightInput_lr = false
extendStyle_lr = extendLeftInput_lr and extendRightInput_lr ? extend.both : 
             extendLeftInput_lr ? extend.left : 
             extendRightInput_lr ? extend.right : 
             extend.none

group3_lr = "Color Settings"
colorUpper_lr =color.new(color.blue, 90)
colorLower_lr =color.new(color.red, 90)

calcSlope_lr(source_lr, length_lr) =>
    max_bars_back(source_lr, 5000)
    if barstate.isconfirmed or (barstate.islast and (run == 1))
        sumX_lr     = 0.0
        sumY_lr     = 0.0
        sumXSqr_lr  = 0.0
        sumXY_lr    = 0.0
        for i_lr = 0 to length_lr - 1
            val_lr      = source_lr[i_lr]
            per_lr      = i_lr + 1.0
            sumX_lr     += per_lr
            sumY_lr     += val_lr
            sumXSqr_lr  += per_lr * per_lr
            sumXY_lr    += val_lr * per_lr
        //
        slope_lr        = (length_lr * sumXY_lr - sumX_lr * sumY_lr) / (length_lr * sumXSqr_lr - sumX_lr * sumX_lr)
        average_lr      = sumY_lr / length_lr
        intercept_lr    = average_lr - slope_lr * sumX_lr / length_lr + slope_lr
        [slope_lr, average_lr, intercept_lr]
    //

[s_lr, a_lr, i_lr] = calcSlope_lr(sourceInput_lr, lengthInput_lr)
startPrice_lr = i_lr + s_lr * (lengthInput_lr - 1)
endPrice_lr = i_lr

var line baseLine_lr = na

if show_plot or run == 0 or run == 1 

    if na(baseLine_lr) and not na(startPrice_lr)
        baseLine_lr := line.new(bar_index - lengthInput_lr + 1, startPrice_lr, bar_index, endPrice_lr, width=1, extend=extendStyle_lr, color=color.new(colorLower_lr, 0), force_overlay = true)
    else
        if not na(startPrice_lr)
            line.set_xy1(baseLine_lr, bar_index - lengthInput_lr + 1, startPrice_lr)
            line.set_xy2(baseLine_lr, bar_index, endPrice_lr)
    //

calcDev_lr(source_lr, length_lr, slope_lr, average_lr, intercept_lr) =>
    if barstate.isconfirmed or (barstate.islast and (run == 1))
        upDev_lr        = 0.0
        dnDev_lr        = 0.0
        stdDevAcc_lr    = 0.0
        dsxx_lr         = 0.0
        dsyy_lr         = 0.0
        dsxy_lr         = 0.0
        periods_lr      = length_lr - 1
        daY_lr          = intercept_lr + slope_lr * periods_lr / 2
        val_lr          = intercept_lr
        for j_lr = 0 to periods_lr
            price_lr = high[j_lr] - val_lr
            if price_lr > upDev_lr
                upDev_lr := price_lr
            price_lr := val_lr - low[j_lr]
            if price_lr > dnDev_lr
                dnDev_lr := price_lr
            price_lr := source_lr[j_lr]
            dxt_lr = price_lr - average_lr
            dyt_lr = val_lr - daY_lr
            price_lr -= val_lr
            stdDevAcc_lr += price_lr * price_lr
            dsxx_lr += dxt_lr * dxt_lr
            dsyy_lr += dyt_lr * dyt_lr
            dsxy_lr += dxt_lr * dyt_lr
            val_lr += slope_lr
        //
        stdDev_lr   = math.sqrt(stdDevAcc_lr / (periods_lr == 0 ? 1 : periods_lr))
        pearsonR_lr = dsxx_lr == 0 or dsyy_lr == 0 ? 0 : dsxy_lr / math.sqrt(dsxx_lr * dsyy_lr)
        [stdDev_lr, pearsonR_lr, upDev_lr, dnDev_lr]


[stdDev_lr, pearsonR_lr, upDev_lr, dnDev_lr] = calcDev_lr(sourceInput_lr, lengthInput_lr, s_lr, a_lr, i_lr)
//
upperStartPrice_lr  = startPrice_lr + (useUpperDevInput_lr ? upperMultInput_lr * stdDev_lr : upDev_lr)
upperEndPrice_lr    = endPrice_lr   + (useUpperDevInput_lr ? upperMultInput_lr * stdDev_lr : upDev_lr)

lowerStartPrice_lr  = startPrice_lr + (useLowerDevInput_lr ? -lowerMultInput_lr * stdDev_lr : -dnDev_lr)
lowerEndPrice_lr    = endPrice_lr   + (useLowerDevInput_lr ? -lowerMultInput_lr * stdDev_lr : -dnDev_lr)

var line upper_lr = na
var line lower_lr = na

if show_plot or run == 0 or run == 1 
    if na(upper_lr) and not na(upperStartPrice_lr)
        upper_lr := line.new(bar_index - lengthInput_lr + 1, upperStartPrice_lr, bar_index, upperEndPrice_lr, width=1, extend=extendStyle_lr, color=color.new(colorUpper_lr, 0), force_overlay = true)
    else
        if not na(upperStartPrice_lr)
            line.set_xy1(upper_lr, bar_index - lengthInput_lr + 1, upperStartPrice_lr)
            line.set_xy2(upper_lr, bar_index, upperEndPrice_lr)
        //
    if na(lower_lr) and not na(lowerStartPrice_lr)
        lower_lr := line.new(bar_index - lengthInput_lr + 1, lowerStartPrice_lr, bar_index, lowerEndPrice_lr, width=1, extend=extendStyle_lr, color=color.new(colorUpper_lr, 0), force_overlay = true)
    else
        if not na(lowerStartPrice_lr)
            line.set_xy1(lower_lr, bar_index - lengthInput_lr + 1, lowerStartPrice_lr)
            line.set_xy2(lower_lr, bar_index, lowerEndPrice_lr)
        //
    if not na(upper_lr) and not na(baseLine_lr)
        linefill.new(upper_lr, baseLine_lr, color = colorUpper_lr)
    if not na(baseLine_lr) and not na(lower_lr)
        linefill.new(baseLine_lr, lower_lr, color = colorLower_lr)
    //

float trend_lr = math.sign(startPrice_lr - endPrice_lr)

// Memorizza i valori precedenti di Pearson e percent_change
var float prev_pearsonR         = na
var float prev_percent_change   = na
var float perc_pearson          = na 

var bool  trend_up          = false 
var float perc_trend        = na 

// Calcola la pendenza come percentuale
percent_change = (endPrice_lr - startPrice_lr) * 100 / startPrice_lr

if percent_change >= 0 and barstate.isconfirmed and run > 0
    trend_up := true
else
    trend_up := false
//

real_pearson = trend_up ? pearsonR_lr : -pearsonR_lr

lr_distance = upperStartPrice_lr - lowerStartPrice_lr
lr_vol_perc := 100 - (((global_distance - lr_distance)/global_distance)*100)
//

lower_lr_perc = math.round(((lowerEndPrice_lr - bot) / global_distance) * 100)
upper_lr_perc = math.round(((upperEndPrice_lr - bot) / global_distance) * 100)
m = (endPrice_lr - startPrice_lr) / (bar_index - (bar_index - lengthInput_lr + 1))
//

// -------------------------------------}

//Analisi e figure
// ------------------------------------------------------------{

// Setting Finonacci + organizzazione livelli in base a status vix e timeframe corrente
// -----------------------------------------------------------{

//Tutto lo scenario bot top viene suddiciso in una sequenza di fibonacci per gestire livelli minimi di acquisto ed eventuali incrementi o diminuzioni della % di volume pesata. questo per mantenere stabilità nel codice ed evitare iper compressioni o iper estensioni
//Gestione dello scenario box 
var float fib_val_value = na 
var float fib_vah_value = na 

var float fib_perc_0 = 0     // Livello 0%
var float fib_perc_1 = 23.6  // Livello 23.6%
var float fib_perc_2 = 38.2  // Livello 38.2%
var float fib_perc_3 = 50    // Livello 50% (non tecnicamente Fibonacci, ma usato comunemente)
var float fib_perc_4 = 61.8  // Livello 61.8% (sezione aurea inversa)
var float fib_perc_5 = 78.6  // Livello 78.6% (radice quadrata di 0.618)
var float fib_perc_6 = 100   // Livello 100%

// Determina in quale zona di Fibonacci si trova VAL
fib_val_value := val_perc <= fib_perc_1 ? 1 : 
             val_perc <= fib_perc_2 ? 2 : 
             val_perc <= fib_perc_3 ? 3 : 
             val_perc <= fib_perc_4 ? 4 : 
             val_perc <= fib_perc_5 ? 5 : 
             val_perc <= fib_perc_6 ? 6 : 6

// Determina in quale zona di Fibonacci si trova VAH
fib_vah_value := vah_perc <= fib_perc_1 ? 1 : 
             vah_perc <= fib_perc_2 ? 2 : 
             vah_perc <= fib_perc_3 ? 3 : 
             vah_perc <= fib_perc_4 ? 4 : 
             vah_perc <= fib_perc_5 ? 5 : 
             vah_perc <= fib_perc_6 ? 6 : 6
//

fib_perc_5_value = bot + (global_distance * fib_perc_5 / 100)
bot_liq_distance = top - bot_liq 
new_fib_perc_5 = math.round(((fib_perc_5 - bot_liq) / bot_liq_distance) * 100)

var float fib_for_break     = na 
var float fib_for_scenario  = na 

if timeframe_level == 0
    if sentiment_level[1] == 0
        fib_for_scenario := fib_perc_3
    else 
        fib_for_scenario := fib_perc_4
    //
    if sentiment_level[1] > 2 and tot_res > 0
        fib_for_break := fib_perc_5
    else
        fib_for_break := fib_perc_4
//
else
    fib_for_scenario := fib_perc_4
    //
    if sentiment_level[1] > 1 and tot_res > 0
        fib_for_break := fib_perc_5
    else
        fib_for_break := fib_perc_4
//

// -------------------------------------}

// Ema per identificare la zona di prezzo
// -----------------------------------------------------------{

//Utilizzo una ema per validare i livelli in questione ed evitare trig di livelli sgraditi durante eventuali salti grafici
var float ema_switch_perc = na 
var bool val_is_in_buy = false     //Lavorando con la ema scindo i livelli validi da quelli invalidi
var bool vah_is_in_buy = false     //Lavorando con la ema scindo i livelli validi da quelli invalidi
var bool poc_is_in_buy = false     //Lavorando con la ema scindo i livelli validi da quelli invalidi
var bool poc_2_is_in_buy = false   //Lavorando con la ema scindo i livelli validi da quelli invalidi
var bool bot_liq_is_in_buy = false //Lavorando con la ema scindo i livelli validi da quelli invalidi

//Selezione di provenienza del trend 
var int lenght_ema = (current_timeframe == "1S" or current_timeframe == "5S" or current_timeframe == "10S") ? 13 :
 (current_timeframe == "15S" or current_timeframe == "30S" or current_timeframe == "45S") ? 11 : 
 (current_timeframe == "1" or current_timeframe == "3" or current_timeframe == "5") ? 7 : 5
ema = ta.ema(close, lenght_ema)
ema_trend_up =   ema > ema[1] and barstate.isconfirmed
ema_trend_down = ema < ema[1] and barstate.isconfirmed 

ema_switch_up = ema_trend_down[1] and ema_trend_up and barstate.isconfirmed
ema_switch_down = ema_trend_up[1] and ema_trend_down and barstate.isconfirmed

var float ema_value_before_start = na 

//Verifico che per le partenze di val e poi - o comunque di tutte le partenze non in bot o sup, la provenienza del trend sia alta.
if ema_switch_up 
    ema_value_before_start := ta.lowest(low, lenght_ema/2) 
if ema_switch_down
    ema_value_before_start := ta.highest(high, lenght_ema/2)
    last_ema_switch_down := ema_value_before_start
    contatore_ema_switch_down := 0 
//
if not ema_switch_down
    contatore_ema_switch_down += 1
//

//Interpolazione di prezzo per evitare falsi segnali 
var float prezzo_interpolato_lr_start = na 
if run == 1 
    prezzo_interpolato_lr_start := upperStartPrice_lr + (upperEndPrice_lr - upperStartPrice_lr) * (bbars - contatore_ema_switch_down) / bbars
//
if not na(prezzo_interpolato_lr_start) and ema_switch_down
    prezzo_interpolato_lr_start := na 
    //

ema_over_lr = (last_ema_switch_down > upperEndPrice_lr[contatore_ema_switch_down] and bbars == (bbars[1] + 1)) or 
 (not na(prezzo_interpolato_lr_start) and last_ema_switch_down > prezzo_interpolato_lr_start )


if run > 0
    if ema_value_before_start > val_level and high[1] > val_level
        val_is_in_buy := true 
    else
        val_is_in_buy := false 
    //
    if ema_value_before_start > vah_level and high[1] > vah_level
        vah_is_in_buy := true 
    else
        vah_is_in_buy := false 
    //
    if ema_value_before_start > poc_level and high[1] > poc_level
        poc_is_in_buy := true 
    else
        poc_is_in_buy := false 
    //
    if ema_value_before_start > poc_second_level and high[1] > poc_second_level
        poc_2_is_in_buy := true 
    else
        poc_2_is_in_buy := false 
    //
    if ema_value_before_start > bot_liq and high[1] > bot_liq
        bot_liq_is_in_buy := true 
    else
        bot_liq_is_in_buy := false 
//

// -------------------------------------}

// Volume analisi
// -----------------------------------------------------------{

//Analisi sommaria del volume, al momento questa prima struttura di analisi risulta povera di funzioni utili salvo per il livello top compression, sono sicuro che un'analisi della coordinazione del volume potrebbe scindere pattern diversi
var string volume_top_condition = na 
var string volume_mid_condition = na 
var string volume_bot_condition = na 

var int top_level_vol = na 
var int mid_level_vol = na 
var int bot_level_vol = na 

bot_vol_ratio = val_to_bot_volume_perc / val_perc
mid_vol_ratio = central_volume_perc / vol_distance_perc
top_vol_ratio = vah_to_top_volume_perc / (100 - vah_perc)

if run > 0 
    //Sezione bot
    if val_perc <= 5
        volume_bot_condition := "No data"
        bot_level_vol := 0 
    else if bot_vol_ratio <= 0.4 and volume_bot_condition != "Spike"
        volume_bot_condition := "Spike"
        bot_level_vol := 1 
    else if bot_vol_ratio > 0.4 and bot_vol_ratio <= 0.7 and volume_bot_condition != "Basso"
        volume_bot_condition := "Basso"
        bot_level_vol := 2 
    else if bot_vol_ratio > 0.7 and bot_vol_ratio <= 0.9 and volume_bot_condition != "Medio"
        volume_bot_condition := "Medio"     
        bot_level_vol := 3 
    else if bot_vol_ratio > 0.9 and bot_vol_ratio <= 1.1 and volume_bot_condition != "Forte"
        volume_bot_condition := "Forte"
        bot_level_vol := 4 
    else if bot_vol_ratio > 1.1 and volume_bot_condition != "Iper"
        volume_bot_condition := "Iper"
        bot_level_vol := 5 
    //Sezione top 
    if vah_perc >= 95
        volume_top_condition := "No data"
        top_level_vol := 0 
    else if top_vol_ratio <= 0.4 and volume_top_condition != "Spike"
        volume_top_condition := "Spike"
        top_level_vol := 1 
    else if top_vol_ratio > 0.4 and top_vol_ratio <= 0.7 and volume_top_condition != "Basso"
        volume_top_condition := "Basso"
        top_level_vol := 2 
    else if top_vol_ratio > 0.7 and top_vol_ratio <= 0.9 and volume_top_condition != "Medio"
        volume_top_condition := "Medio"     
        top_level_vol := 3 
    else if top_vol_ratio > 0.9 and top_vol_ratio <= 1.1 and volume_top_condition != "Forte"
        volume_top_condition := "Forte"
        top_level_vol := 4 
    else if top_vol_ratio > 1.1 and volume_top_condition != "Iper"
        volume_top_condition := "Iper"
        top_level_vol := 5 
    //Sezione mid 
    if mid_vol_ratio <= 0.5 and volume_mid_condition != "Micro"
        volume_mid_condition := "Micro"
        mid_level_vol := 1
    else if mid_vol_ratio > 0.5 and mid_vol_ratio <= 0.8 and volume_mid_condition != "Basso"
        volume_mid_condition := "Basso"
        mid_level_vol := 2
    else if mid_vol_ratio > 0.8 and mid_vol_ratio <= 1.2 and volume_mid_condition != "Medio"
        volume_mid_condition := "Medio"     
        mid_level_vol := 3
    else if mid_vol_ratio > 1.2 and mid_vol_ratio <= 1.5 and volume_mid_condition != "Forte"
        volume_mid_condition := "Forte"
        mid_level_vol := 4
    else if mid_vol_ratio > 1.5 and volume_mid_condition != "Iper"
        volume_mid_condition := "Iper"
        mid_level_vol := 5
    //

var string volume_dispersion = na 

if mid_level_vol >= 4
    if top_level_vol == 0 and volume_dispersion != "No Top Data"
        volume_dispersion := "No Top Data"
    else if bot_level_vol == 0 and volume_dispersion != "No Bot Data"
        volume_dispersion := "No Bot Data"
    else if bot_level_vol >= 4 and top_level_vol >= 4 and volume_dispersion != "No Vol Focus"
        volume_dispersion := "No Vol Focus"
    else if bot_level_vol >= 4 and top_level_vol < 4 and volume_dispersion != "Bot - Mid Dispersion"
        volume_dispersion := "Bot - Mid Dispersion"
    else if top_level_vol >= 4 and bot_level_vol < 4 and volume_dispersion != "Top - Mid Dispersion"
        volume_dispersion := "Top - Mid Dispersion"
    else if mid_level_vol == 4 and top_level_vol < 4 and bot_level_vol < 4 and volume_dispersion != "Focus Mid Vol"
        volume_dispersion := "Focus Mid Vol"
    else if mid_level_vol == 5 and top_level_vol < 4 and bot_level_vol < 4 and volume_dispersion != "Iper Focus Mid Vol"
        volume_dispersion := "Iper Focus Mid Vol"
    //

if mid_level_vol < 4 
    if top_level_vol == 0 and volume_dispersion != "No Top Data"
        volume_dispersion := "No Top Data"
    else if bot_level_vol == 0 and volume_dispersion != "No Bot Data"
        volume_dispersion := "No Bot Data"
    else if bot_level_vol >= 4 and top_level_vol >= 4 and volume_dispersion != "Top - Bot Focus"
        volume_dispersion := "Top - Bot Focus"
    else if bot_level_vol >= 4 and top_level_vol < 4 and volume_dispersion != "Bot Dispersion"
        volume_dispersion := "Bot Dispersion"
    else if top_level_vol >= 4 and bot_level_vol < 4 and volume_dispersion != "Top Dispersion"
        volume_dispersion := "Top Dispersion"
    else if top_level_vol < 4 and bot_level_vol < 4 and volume_dispersion != "Vol Fluido"
        volume_dispersion := "Vol Fluido"
    //
//

// -------------------------------------}

// Market analisi 
// -----------------------------------------------------------{

var string market = na 
var bool active_mid_trade = false 
var string market_buy_pattern = na 
var float low_level = na 
var int start_perc = na 

// Ricalcolo di fib_perc_4 rispetto al nuovo livello 0 (bot_liq_perc)
var int new_poc_perc = na

if not na(bot) and bot != 0  // Evita la divisione per zero
    new_poc_perc := math.round((poc_perc * bot_liq_perc) / bot)
else
    // Se fib_perc_4 è minore o uguale a bot_liq_perc, allora la nuova percentuale è 0
    new_poc_perc := na
//

var float break_start_perc = na 

// Analisi generale di mercato 
if run > 0
    //Stringhe d'ingresso con run == 1 
    if run == 1 and bot_is_sup and not trend_up 
        market := "Fall Accumula Liq"
    if run == 1 and bot_is_sup and trend_up 
        market := "Trend Up"
    if run == 1 and not bot_is_sup and not trend_up 
        market := "Trend Down"
    if run == 1 and not bot_is_sup and trend_up 
        market := "Fall Spike Up"
    //
    //Iterazioni post inizializzazione per incrociare i dati di start
    if market == "Fall Spike Up" and bot_is_sup 
        market := "Trend Up"
    if market == "Fall Spike Up" and not trend_up 
        market := "Trend Down"
    if market == "Fall Accumula Liq" and trend_up 
        market := "Trend Up"
    if market == "Fall Accumula Liq" and not bot_is_sup 
        market := "Trend Down"
    if market == "Trend Up" and not trend_up
        market := "Fall Accumula Liq"
    if market == "Trend Down" and bot_is_sup 
        market := "Fall Accumula Liq"
    if market == "Trend Down" and trend_up
        market := "Fall Spike Up"
    //
    //Iterazione per prevedere lo switch del trend verso l'alto 
    if (market == "Fall Accumula Liq" or market == "Trend Down") and (high > upperEndPrice_lr or ema_switch_perc > upper_lr_perc )
        market := "Switch Up Trend"
    if market == "Switch Up Trend" and (trend_up)
        market := "Trend Up"
    if market == "Switch Up Trend" and low < bot_liq
        market := "Trend Down"
    // 
    //Passaggio alle definizioni dei pattern di gioco 
    if market == "Fall Accumula Liq" or market == "Trend Up" or market == "Fall Spike Up" or market == "Switch Up Trend" or (market == "Trend Down" and pearsonR_lr < 0.2 )
        active_mid_trade := true 
    else 
        active_mid_trade := false  
        market_buy_pattern := "No Buy Pattern" 
    //
    //Impostazione degli scenari quando l'analisi di mercato fornisce un responso d'analisi
    if active_mid_trade 
        low_level := math.min(val_level, poc_second_level)
        //Definizione delle figure
        figura_vah_to_bot_target = vah_perc <= fib_for_scenario and vah_perc <= (lower_lr_perc) and vah_perc > (bot_liq_perc)
         and vah_is_in_buy and 
         (na(break_start_perc) or (not na(break_start_perc) and vah_perc[1]   < (break_start_perc - (min_level[1] / 2)))) //Questa struttura serve per abbassare la posizione mid quando la posizone break è aperta
 
        figura_poc_to_bot_target = ((poc_perc <= fib_for_scenario) or (not na(new_fib_perc_5) and new_poc_perc <= new_fib_perc_5)) 
         and poc_perc <= (lower_lr_perc) and poc_perc > (bot_liq_perc) 
         and poc_is_in_buy and not figura_vah_to_bot_target and 
         (na(break_start_perc) or (not na(break_start_perc) and poc_perc[1]   < (break_start_perc - (min_level[1] / 2))))

        figura_val_to_bot_target = (val_perc <= fib_for_scenario and val_perc <= (lower_lr_perc) and val_perc > (bot_liq_perc)
         and val_is_in_buy and not figura_poc_to_bot_target) and not figura_poc_to_bot_target and not figura_vah_to_bot_target and 
         (na(break_start_perc) or (not na(break_start_perc) and val_perc[1]   < (break_start_perc - (min_level[1] / 2))))

        figura_poc_2_to_bot_target = ((poc_2_perc <= fib_for_scenario and poc_2_perc <= (lower_lr_perc) and poc_2_perc > (bot_liq_perc)
         and poc_2_is_in_buy and not figura_val_to_bot_target and not figura_vah_to_bot_target and not figura_poc_to_bot_target and low_level == poc_second_level) or 
         (poc_2_perc <= fib_for_scenario and poc_2_perc <= (lower_lr_perc) and poc_2_perc > bot_liq_perc and poc_2_is_in_buy and poc_second_level > poc_level and poc_2_to_poc_vol_ratio > 50)) and 
         (na(break_start_perc) or (not na(break_start_perc) and poc_2_perc[1] < (break_start_perc - (min_level[1] / 2))))

        figura_bot_liq = not figura_vah_to_bot_target and not figura_val_to_bot_target and not figura_poc_to_bot_target and not figura_poc_2_to_bot_target

        //
        if low_level <= lowerEndPrice_lr //Impostazione degli scenari quando i livelli di poc sono sotto la lr attuale
            if not up_breakout
                //Vah
                if market_buy_pattern  != "Vah Buy Fig" and figura_vah_to_bot_target 
                    market_buy_pattern := "Vah Buy Fig"
                    start_perc := vah_perc
                //
                if market_buy_pattern  == "Vah Buy Fig" and not figura_vah_to_bot_target
                    market_buy_pattern := na 
                    start_perc := na 
                //Poc 
                if market_buy_pattern  != "Poc Buy Fig" and figura_poc_to_bot_target
                    market_buy_pattern := "Poc Buy Fig"
                    start_perc := poc_perc 
                //
                if market_buy_pattern  == "Poc Buy Fig" and not figura_poc_to_bot_target
                    market_buy_pattern := na 
                    start_perc := na 
                //Poc 2
                if market_buy_pattern  != "Poc 2 Buy Fig" and figura_poc_2_to_bot_target
                    market_buy_pattern := "Poc 2 Buy Fig"
                    start_perc := poc_2_perc 
                //
                if market_buy_pattern  == "Poc 2 Buy Fig" and not figura_poc_2_to_bot_target
                    market_buy_pattern := na 
                    start_perc := na 
                //Val
                if market_buy_pattern  != "Val Buy Fig" and figura_val_to_bot_target 
                    market_buy_pattern := "Val Buy Fig"
                    start_perc := val_perc 
                //
                if market_buy_pattern  == "Val Buy Fig" and not figura_val_to_bot_target
                    market_buy_pattern := na 
                    start_perc := na 
                //Bot Liq
                if market_buy_pattern  != "Bot Liq Fig" and figura_bot_liq 
                    market_buy_pattern := "Bot Liq Fig"
                //
                if market_buy_pattern  == "Bot Liq Fig" and not figura_bot_liq
                    market_buy_pattern := na 
                //
            else 
                market_buy_pattern := "Break-out Fig"
            //

            ///////////////
            //Impostazioni degli scenari di break - la attuale percentuale 15% dovrebbe diventare un dato modificato dal timeframe corrente, sarebbe opportuno inizializzarlo allo start del codice 
            if market_buy_pattern == "Break-out Fig"
                if poc_second_level > poc_level 
                    if break_out_up_perc_mom > 13 and poc_perc < fib_for_break and poc_is_in_buy
                        market_buy_pattern := "Poc Break"
                    if break_out_up_perc_mom > 13 and (vah_perc < fib_for_break) and vah_is_in_buy
                        market_buy_pattern := "Vah Break"
                    if break_out_up_perc_mom > 13 and (poc_2_to_poc_vol_ratio > 50 and poc_2_perc < fib_for_break) and poc_2_is_in_buy
                        market_buy_pattern := "Poc 2 Break"
                //
                if poc_second_level < poc_level 
                    if break_out_up_perc_mom > 13 and (poc_2_to_poc_vol_ratio > 50 and poc_2_perc < fib_for_break) and poc_2_is_in_buy
                        market_buy_pattern := "Poc 2 Break"
                    if break_out_up_perc_mom > 13 and poc_perc < fib_for_break and poc_is_in_buy
                        market_buy_pattern := "Poc Break"
                    if break_out_up_perc_mom > 13 and (vah_perc < fib_for_break) and vah_is_in_buy
                        market_buy_pattern := "Vah Break"
                //
                if ((market_buy_pattern == "Break-out Fig" and val_level > bot_liq) or (market_buy_pattern == "Poc 2 Break" and val_level > poc_second_level and val_perc < fib_perc_5)) and val_is_in_buy
                    market_buy_pattern := "Val Break"
                //
                if market_buy_pattern == "Break-out Fig"
                    "No data after break" 
        //
        if low_level > lowerEndPrice_lr //Ricerca di scenari più bassi quando il poc è compreso nella lr
            market_buy_pattern := "Pendant Study" 
            if low_level == val_level
                start_perc := val_perc
            if low_level == poc_second_level
                start_perc := poc_2_perc
            if market_buy_pattern == "Pendant Study" and val_perc > 70
                 and (na(break_start_perc) or (not na(break_start_perc)  and val_perc[1]  < (break_start_perc - (min_level[1] / 2))))
                market_buy_pattern := "Top Compression"
            if market_buy_pattern == "Pendant Study" and vah_perc < 30
                 and (na(break_start_perc) or (not na(break_start_perc) and vah_perc[1]   < (break_start_perc - (min_level[1] / 2))))
                market_buy_pattern := "Bot Compression"
            if market_buy_pattern == "Pendant Study" and val_is_in_buy
                 and (na(break_start_perc) or (not na(break_start_perc) and val_perc[1]   < (break_start_perc - (min_level[1] / 2))))
                market_buy_pattern := "Val"
            if market_buy_pattern == "Pendant Study" and not val_is_in_buy and bot_liq_is_in_buy
                market_buy_pattern := "Bot Liq"
        if  market == "Switch Up Trend" and not trend_up and pearsonR_lr > 0.75 //Scenario Max - l'idea è che lo sfondamento di una lr mobile indica un volume che ha nettamente rotto il trend. Sarebbe opportuno iterare la Siffredi solo quando real_pearson < -0.9/0.8 in questo modo mi assicuro che quel trend sta davvero cadendo
            market_buy_pattern := "Siffredi" 
        if  market == "Switch Up Trend" and not trend_up and pearsonR_lr < 0.75 
            market_buy_pattern := "Siffredi look for break" 
        //

// -------------------------------------}

//Gestione dei livelli di target
// -----------------------------------------------------------{

// Inizializza le variabili target
var float lower_target = na
var float higher_target = na
var float lower_target_bot = na
var float higher_target_bot = na
var float lower_target_actual_support_over_bot = na
var float higher_target_actual_support_over_bot = na
var int save_start_perc = na 
var int open_position_mid = 0 
var int open_position_bot = 0 
var int open_position_break = 0
var bool save_start_perc_bool = false 
var float mid_ask = na

var int mid_perc_min = 0
var int mid_perc_mid = 0

if open_position_mid == 0 
    save_start_perc := start_perc 
    if save_start_perc_bool
        save_start_perc_bool := false  
if open_position_mid > 0 and not save_start_perc_bool
    save_start_perc := start_perc[1]
    save_start_perc_bool := true 
//
if save_start_perc_bool and bot != bot[1]
    save_start_perc := math.round(((mid_ask - bot) / global_distance) * 100)
//

mid_perc_min := save_start_perc + min_level
mid_perc_mid := ((100 - mid_perc_min) / 2 ) + mid_perc_min

// Array monodimensionale per metriche percentuali di liquidità
var orig_perc_array = array.new_float(6)

// Popolamento struttura vettoriale con parametrizzazione sequenziale
array.set(orig_perc_array, 0, bot_liq_perc)
array.set(orig_perc_array, 1, val_perc)
array.set(orig_perc_array, 2, poc_perc)
array.set(orig_perc_array, 3, vah_perc)
array.set(orig_perc_array, 4, top_liq_perc)
array.set(orig_perc_array, 5, poc_2_perc)

// Costanti critiche per thresholding
var float first_bot_liq = na 
int perc_mid = mid_level
var int bot_liq_perc_used = na 

//Imposto le percentuali per il bot 
if na(first_bot_liq)
    bot_liq_perc_used := bot_liq_perc
else
    bot_liq_perc_used := math.round(((first_bot_liq - bot) / global_distance) * 100)
//

bot_perc_min = bot_liq_perc_used + min_level
bot_perc_mid = ((100 - bot_perc_min) / 2 ) + bot_perc_min

actual_support_over_bot_perc_min = actual_support_over_bot_perc + min_level
actual_support_over_bot_perc_mid = ((100 - actual_support_over_bot_perc_min) / 2 ) + actual_support_over_bot_perc_min

// Funzione ottimizzata per calcolo target percentuali con parametrizzazione threshold
calculate_target_percentages(float[] price_array, int min_threshold, int mid_threshold) =>
    // Dichiarazione variabili di output
    float lower_target_percentage = na
    float higher_target_percentage = na
    
    // Clonazione e ordinamento decrescente
    float[] sorted_array = array.copy(price_array)
    array.sort(sorted_array, order.descending)
    
    // Prima fase: Ricerca del valore nell'intervallo ideale (min_threshold, mid_threshold]
    bool found_under_mid = false
    int below_mid_index = -1
    
    for i = 0 to array.size(sorted_array) - 1
        if array.get(sorted_array, i) <= mid_threshold and array.get(sorted_array, i) > min_threshold 
            found_under_mid := true
            below_mid_index := i
            break
    
    // Logica decisionale
    if found_under_mid
        // Il valore è nell'intervallo ideale
        lower_target_percentage := array.get(sorted_array, below_mid_index)
        higher_target_percentage := below_mid_index > 0 ? 
                                  array.get(sorted_array, below_mid_index - 1) : 
                                  lower_target_percentage
    else
        // Reset ordinamento per caso edge - nessun valore nell'intervallo ideale
        array.sort(sorted_array, order.ascending)
        bool found_over_mid = false
        
        // Cerchiamo il primo valore sopra mid_threshold
        for i = 0 to array.size(sorted_array) - 1
            if array.get(sorted_array, i) > mid_threshold
                lower_target_percentage := array.get(sorted_array, i)
                higher_target_percentage := i > 0 ? 
                                          array.get(sorted_array, i - 1) : 
                                          lower_target_percentage
                found_over_mid := true
                break
        
        // Caso limite: nessun valore maggiore di mid_threshold
        if not found_over_mid
            lower_target_percentage := array.get(sorted_array, array.size(sorted_array) - 1)
            higher_target_percentage := lower_target_percentage
    
    [lower_target_percentage, higher_target_percentage]    
//

// Applicazione della funzione con parametri di thresholding definiti
[lower_target_perc, higher_target_perc] = calculate_target_percentages(orig_perc_array, min_level, perc_mid)
[lower_target_perc_bot, higher_target_perc_bot] = calculate_target_percentages(orig_perc_array, bot_perc_min, bot_perc_mid)
[lower_target_actual_support_over_bot_perc, higher_target_actual_support_over_bot_perc] = calculate_target_percentages(orig_perc_array, actual_support_over_bot_perc_min, actual_support_over_bot_perc_mid)

// Correzione vettoriale con epsilon-bound comparison per float
get_level_from_perc(target_perc) =>
    float ret_level = na
    
    // Implementazione direct-mapping con strict equality first
    if target_perc == bot_liq_perc
        ret_level := bot_liq
    else if target_perc == val_perc
        ret_level := val_level
    else if target_perc == poc_perc
        ret_level := poc_level
    else if target_perc == vah_perc
        ret_level := vah_level
    else if target_perc == top_liq_perc
        ret_level := top_liq
    else if target_perc == poc_2_perc
        ret_level := poc_second_level
    else if target_perc == actual_support_over_bot_perc
        ret_level := actual_supporto
    ret_level

// Assegnazione deterministica con mappatura biiettiva 
lower_target        := get_level_from_perc(lower_target_perc)
higher_target       := get_level_from_perc(higher_target_perc)
lower_target_bot    := get_level_from_perc(lower_target_perc_bot)
higher_target_bot   := get_level_from_perc(higher_target_perc_bot)
lower_target_actual_support_over_bot    := get_level_from_perc(lower_target_actual_support_over_bot_perc)
higher_target_actual_support_over_bot    := get_level_from_perc(higher_target_actual_support_over_bot_perc)

var float mid_lower_target  = na
var float mid_higher_target = na

// -------------------------------------}

// -------------------------------------}

// Logica posizioni intermedie e trig di ingresso
// -----------------------------------------------------------{

// Var posizioni 
// -----------------------------------------------------------{

var float total_gain = 0
var float gain       = 0 
var int posizione_attive_no_cover = 0

//Scenario Bot Line 
var bool scenario_bot_line       = false 
var bool scenario_bot_2_line     = false 

var int scenario_bot_line_to_h = 0
var int scenario_bot_line_to_l = 0
var float scenario_bot_ask_to_h  = 0
var float scenario_bot_ask_to_l  = 0 

var float supporto_1 = na 
var float supporto_2 = na 
var float supporto_3 = na 
var float supporto_4 = na 

//Scenario Cover Line 
var bool cover_1_line          = false 
var bool cover_2_line          = false 
var bool cover_3_line          = false 
var bool cover_4_line          = false 

var bool supporto_cover_trig_1 = false 
var bool supporto_cover_trig_2 = false 
var bool supporto_cover_trig_3 = false 
var bool supporto_cover_trig_4 = false 

var int scenario_cover_1_line_to_h = 0
var int scenario_cover_1_line_to_l = 0
var float scenario_cover_1_ask_to_h  = 0
var float scenario_cover_1_ask_to_l  = 0 

var int scenario_cover_2_line_to_h = 0
var int scenario_cover_2_line_to_l = 0
var float scenario_cover_2_ask_to_h  = 0
var float scenario_cover_2_ask_to_l  = 0 

var int scenario_cover_3_line_to_h = 0
var int scenario_cover_3_line_to_l = 0
var float scenario_cover_3_ask_to_h  = 0
var float scenario_cover_3_ask_to_l  = 0 

var int scenario_cover_4_line_to_h = 0
var int scenario_cover_4_line_to_l = 0
var float scenario_cover_4_ask_to_h  = 0
var float scenario_cover_4_ask_to_l  = 0 

//Posizioni intermedie 
//Posizione Val to bot target 

var int scenario_val_to_bot_target_line  = 0
var float scenario_val_to_bot_target_ask = 0

var int scenario_poc_to_bot_target_line  = 0
var float scenario_poc_to_bot_target_ask = 0

var int scenario_poc_2_to_bot_target_line  = 0
var float scenario_poc_2_to_bot_target_ask = 0

var int scenario_vah_to_bot_target_line  = 0
var float scenario_vah_to_bot_target_ask = 0

//

var int scenario_val_to_higher_line  = 0 
var float scenario_val_to_higher_ask = 0

//Scenario to res
var int scenario_actual_over_bot_line = 0 
var float scenario_actual_over_bot_ask = 0
//Scenario to breakout

var int scenario_break_out_line = 0 
var float scenario_break_out_ask = 0

//Conteggio posizioni 

var float target_res = na 
var int tot_position_scenario_bot = 0

var bool close_alarm_mid = false 

var int tot_position_scenario_cover_1 = 0 
var int tot_position_scenario_cover_2 = 0 
var int tot_position_scenario_cover_3 = 0 
var int tot_position_scenario_cover_4 = 0 

if close_alarm_mid 
    close_alarm_mid := false 
    scenario_val_to_higher_line         := 0 
    scenario_val_to_higher_ask          := 0 
    scenario_vah_to_bot_target_line     := 0
    scenario_vah_to_bot_target_ask      := 0
    scenario_val_to_bot_target_line     := 0
    scenario_val_to_bot_target_ask      := 0
    scenario_poc_to_bot_target_line     := 0
    scenario_poc_to_bot_target_ask      := 0
    scenario_poc_2_to_bot_target_line   := 0
    scenario_poc_2_to_bot_target_ask    := 0
//

// -------------------------------------}

// Lista trig
// -----------------------------------------------------------{

var int last_cover   = 0
if tot_position_cover == 0 and last_cover > 0
    last_cover := 0
//

if not scenario_bot_line and not scenario_bot_2_line and not na(first_bot_liq)
    first_bot_liq := na 
//

[mid_lower_target_perc, mid_higher_target_perc] = calculate_target_percentages(orig_perc_array, mid_perc_min, mid_perc_mid)

mid_lower_target        := get_level_from_perc(mid_lower_target_perc)
mid_higher_target        := get_level_from_perc(mid_higher_target_perc)

stable_box = bot[1] == bot and top[1] == top 
var float break_ask = na 

if barstate.islast and run > 0
    var int n_posizione = na
    //Trig di apertura
    val_trig_base_act = (
             (high[1] >= val_level          and low <= val_level)         or
             (high_perc[1] >= val_perc      and low_perc <= val_perc)     or
             (low[1] >= val_level           and low <= val_level)         or 
             (low_perc[1] >= val_perc       and low_perc <= val_perc))    and stable_box
             //
    val_trig_base_old = (
             (high[1] >= val_level[1]       and low <= val_level[1]    )  or
             (high_perc[1] >= val_perc[1]   and low_perc <= val_perc[1])  or
             (low[1] >= val_level[1]        and low <= val_level[1]    )  or 
             (low_perc[1] >= val_perc[1]    and low_perc <= val_perc[1])) and stable_box

    val_trig_base = val_trig_base_act or val_trig_base_old
    val_trig = val_trig_base and val_is_in_buy
    val_trig_break = val_trig and low_perc < lower_lr_perc

    vah_trig_base_act = (
             (high[1] >= vah_level          and low <= vah_level)         or
             (high_perc[1] >= vah_perc      and low_perc <= vah_perc)     or
             (low[1] >= vah_level           and low <= vah_level)         or 
             (low_perc[1] >= vah_perc       and low_perc <= vah_perc))    and stable_box
             //
    vah_trig_base_old = (
             (high[1] >= vah_level[1]       and low <= vah_level[1]      ) or
             (high_perc[1] >= vah_perc[1]   and low_perc <= vah_perc[1]  ) or
             (low[1] >= vah_level[1]        and low <= vah_level[1]      ) or 
             (low_perc[1] >= vah_perc[1]    and low_perc <= vah_perc[1] )) and stable_box

    vah_trig_base = vah_trig_base_act or vah_trig_base_old
    vah_trig = vah_trig_base and vah_is_in_buy

    poc_trig_base_act = (
             (high[1] >= poc_level          and low <= poc_level)           or
             (high_perc[1] >= poc_perc      and low_perc <= poc_perc)       or
             (low[1] >= poc_level           and low <= poc_level)           or 
             (low_perc[1] >= poc_perc       and low_perc <= poc_perc))      and stable_box
             //
    poc_trig_base_old = (
             (high[1] >= poc_level[1]       and low <= poc_level[1]      )  or
             (high_perc[1] >= poc_perc[1]   and low_perc <= poc_perc[1]  )  or
             (low[1] >= poc_level[1]        and low <= poc_level[1]      )  or 
             (low_perc[1] >= poc_perc[1]    and low_perc <= poc_perc[1] ))  and stable_box

    poc_trig_base = poc_trig_base_act or poc_trig_base_old
    poc_trig = poc_trig_base and poc_is_in_buy

    poc_2_trig_base_act = (
             (high[1] >= poc_second_level    and low <= poc_second_level)       or
             (high_perc[1] >= poc_2_perc     and low_perc <= poc_2_perc)        or
             (low[1] >= poc_second_level     and low <= poc_second_level)       or 
             (low_perc[1] >= poc_2_perc      and low_perc <= poc_2_perc))       and stable_box    
             //
    poc_2_trig_base_old = (
             (high[1] >= poc_second_level[1] and low <= poc_second_level[1])    or
             (high_perc[1] >= poc_2_perc[1]  and low_perc <= poc_2_perc[1] )    or
             (low[1] >= poc_second_level[1]  and low <= poc_second_level[1])    or 
             (low_perc[1] >= poc_2_perc[1]   and low_perc <= poc_2_perc[1] ))   and stable_box

    poc_2_trig_base = poc_2_trig_base_act or poc_2_trig_base_old
    poc_2_trig = poc_2_trig_base and poc_2_is_in_buy
    poc_2_trig_break = poc_2_trig and low_perc < lower_lr_perc 

    bot_liq_trig = (
             (high[1] >= bot_liq                and low <= bot_liq)                 or
             (high_perc[1] >= bot_liq_perc      and low_perc <= bot_liq_perc)       or
             (low[1] >= bot_liq                 and low <= bot_liq)                 or 
             (low_perc[1] >= bot_liq_perc       and low_perc <= bot_liq_perc)       or 
             //
             (high[1] >= bot_liq[1]             and low <= bot_liq[1]          )    or
             (high_perc[1] >= bot_liq_perc[1]   and low_perc <= bot_liq_perc[1])    or
             (low[1] >= bot_liq[1]              and low <= bot_liq[1]          )    or 
             (low_perc[1] >= bot_liq_perc[1]    and low_perc <= bot_liq_perc[1]) )  and bot_liq_is_in_buy and stable_box

    old_sup_trig = 
             (low[1] > old_sup[1] and low <= old_sup[1]) or
             (low[1] > old_sup and low <= old_sup)

    //Trig di chiusura 
    higher_target_bot_trig = 
             high >= higher_target_bot              or 
             high_perc == higher_target_perc_bot    or 
             high > upperEndPrice_lr                or
             ((high >= higher_target_bot[1]         or 
             high_perc == higher_target_perc_bot[1] or 
             high > upperEndPrice_lr[1]) 
             and stable_box)      

    higher_target_trig = 
             high >= higher_target                  or 
             high_perc == higher_target_perc        or 
             ((high >= higher_target[1]             or 
             high_perc == higher_target_perc[1]) 
             and stable_box)             

    lower_target_bot_trig = 
             high >= lower_target_bot              or 
             high_perc == lower_target_perc_bot    or 
             high > upperEndPrice_lr               or
             ((high >= lower_target_bot[1]         or 
             high_perc == lower_target_perc_bot[1] or 
             high > upperEndPrice_lr[1]) 
             and stable_box)  

    mid_lower_target_bot_trig = 
             (high >= mid_lower_target              or 
             high_perc == mid_lower_target_perc     or 
             high > upperEndPrice_lr                or
             ((high >= mid_lower_target[1]          or 
             high_perc == mid_lower_target_perc[1]  or 
             high > upperEndPrice_lr[1]) 
             and stable_box)) and open_position_mid > 0

    mid_higher_target_bot_trig = 
             (high >= mid_higher_target              or 
             high_perc == mid_higher_target_perc     or 
             high > upperEndPrice_lr                 or
             ((high >= mid_higher_target[1]          or 
             high_perc == mid_higher_target_perc[1]  or 
             high > upperEndPrice_lr[1]) 
             and stable_box)) and open_position_mid > 0
 
    chiusura_scenario_under_lower_lr = ((open_position_break > 0 or pearsonR_lr[1] < 0.75) and stable_box) ? mid_lower_target_bot_trig : mid_higher_target_bot_trig

    actual_support_over_bot_target_trig_lower = 
             high >= lower_target_actual_support_over_bot              or 
             high_perc == lower_target_actual_support_over_bot_perc    or 
             high > upperEndPrice_lr                or
             ((high >= lower_target_actual_support_over_bot[1]         or 
             high_perc == lower_target_actual_support_over_bot_perc[1] or 
             high > upperEndPrice_lr[1]) 
             and stable_box) 
    //

    actual_support_trig = actual_support_over_bot_target_trig_lower 
    //
    any_trig_close = 
         (low[1] < val_level            and high > val_level          )     or
         (low[1] < val_level[1]         and high > val_level[1]       )     or
         (low[1] < vah_level            and high > vah_level          )     or
         (low[1] < vah_level[1]         and high > vah_level[1]       )     or
         (low[1] < poc_level            and high > poc_level          )     or
         (low[1] < poc_level[1]         and high > poc_level[1]       )     or
         (low[1] < poc_second_level     and high > poc_second_level   )     or
         (low[1] < poc_second_level[1]  and high > poc_second_level[1])     or
         (low[1] < top_liq              and high > top_liq      )           or
         (low[1] < top_liq[1]           and high > top_liq[1]   )  

    low_trig  = any_trig_close and high_perc > min_level
    high_trig = any_trig_close and high_perc > mid_level
    //

// -------------------------------------}

// Posizioni in area intermedia di retrend up il seguente blocco possiede tutto lo stesso ID 12 preservando lo stesso ID posso conservare rapidamente un'iterazione di chiusura
// -----------------------------------------------------------{

// Buy Break out ID 13
// -----------------------------------------------------------{
    var bool break_fail = false 
    var bool target_upper_lr = false 

    bool scenario_break_out = false 
    if open_position_break > 0 and tot_position > 1
        break_fail := true 
    //
    if  market_buy_pattern == "Poc 2 Break" 
        scenario_break_out := poc_2_trig_base_act
    if  market_buy_pattern == "Poc Break" 
        scenario_break_out := poc_trig_base_act
    if  market_buy_pattern == "Vah Break" 
        scenario_break_out := vah_trig_base_act
    if  market_buy_pattern[1] == "Poc 2 Break" 
        scenario_break_out := poc_2_trig_base_old
    if  market_buy_pattern[1] == "Poc Break" 
        scenario_break_out := poc_trig_base_old
    if  market_buy_pattern[1] == "Vah Break" 
        scenario_break_out := vah_trig_base_old
    var bool siffredi_fatta = false 
    
    bool scenario_siffredi = false 
    if (market_buy_pattern == "Siffredi" or market_buy_pattern[1] == "Siffredi") or ((market_buy_pattern == "Siffredi look for break" or market_buy_pattern[1] == "Siffredi look for break" ) and not na(old_res))
        scenario_siffredi := ((vah_trig) or (poc_2_trig) or poc_trig or (val_trig)) and not siffredi_fatta

    if scenario_break_out and open_position_mid == 0 and tot_position_scenario_bot == 0 and scenario_break_out_line == 0
        n_posizione := 13
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
          str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_break_out_line := 1
        scenario_break_out_ask  := vah_trig_base_act or vah_trig_base_old ? (vah_level + spread ): poc_2_trig_base_act or poc_2_trig_base_old ? poc_second_level + spread : poc_level + spread 
        //
        break_ask := scenario_break_out_ask
        target_res := low_perc < fib_perc_4 ? top : not na(old_res) ? old_res : upperEndPrice_lr 
        if target_res == upperEndPrice_lr
            target_upper_lr := true 
        break_start_perc := (scenario_break_out_ask - bot) / ((top - bot) * 100)
        label scenario_break = label.new(bar_index, low - (high - low), "scenario break", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_break)

    if scenario_break_out_line == 1 and scenario_break_out_line[1] == 1 and ((high > target_res and not target_upper_lr) or (high > upperEndPrice_lr and target_upper_lr) or break_fail) and high > scenario_break_out_ask
        n_posizione := 13
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        gain := high - scenario_break_out_ask
        total_gain := total_gain + gain
        //
        break_ask := na 
        target_upper_lr := false 
        break_fail := false 
        break_start_perc := na 
        label close_res = label.new(bar_index, high, "close scenario break", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_res)
        //
        target_res := na 
        scenario_actual_over_bot_line := 0
        scenario_break_out_line  := 0
    //
    if scenario_siffredi and open_position_mid == 0 and tot_position_scenario_bot == 0 and scenario_break_out_line == 0 and not siffredi_fatta 
        n_posizione := 23
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
          str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_break_out_line := 1
        scenario_break_out_ask  := vah_trig_base ? (vah_level + spread ): poc_2_trig_base ? poc_second_level + spread : val_trig_base ? val_level + spread : poc_level + spread
        //
        break_ask := scenario_break_out_ask
        target_res := market_buy_pattern == "Siffredi" ? top_liq : old_res
        break_start_perc :=  (scenario_break_out_ask - bot) / ((top - bot) * 100)

        label scenario_break = label.new(bar_index, low - (high - low), "scenario siffredi", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_break)

    if scenario_break_out_line == 1 and scenario_break_out_line[1] == 1 and (high > target_res) and high > scenario_break_out_ask
        n_posizione := 23
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        gain := high - scenario_break_out_ask
        total_gain := total_gain + gain
        //
        break_ask := na 
        break_fail := false 
        break_start_perc := na 
        label close_res = label.new(bar_index, high, "close scenario siffredi", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_res)
        //
        target_res := na 
        scenario_actual_over_bot_line := 0
        scenario_break_out_line  := 0
    //
    if market_buy_pattern == "Siffredi" and scenario_break_out_line == 1 
        siffredi_fatta := true 
    if market_buy_pattern != "Siffredi" and siffredi_fatta
        siffredi_fatta := false 

// -------------------------------------}

//Conteggio posizioni 
// -----------------------------------------------------------{

    open_position_break := scenario_actual_over_bot_line + scenario_break_out_line

// -------------------------------------}

// Buy Pendant
// -----------------------------------------------------------{

    bool scenario_val_to_higher = false 
    var float take_val_to_top = na 
    var float top_data_compression = na 
    var string pendant_trig = na 

    if (market_buy_pattern == "Top Compression" or  market_buy_pattern[1] == "Top Compression")
        scenario_val_to_higher := (val_trig and (val_is_in_buy or val_is_in_buy[1])) 
    if market_buy_pattern == "Val" or  market_buy_pattern[1] == "Val"
        scenario_val_to_higher := val_trig
    if market_buy_pattern == "Bot Liq" or  market_buy_pattern[1] == "Bot Liq"
        scenario_val_to_higher := bot_liq_trig
        
    if scenario_val_to_higher and scenario_val_to_higher_line == 0 and open_position_mid == 0 and open_position_bot == 0 
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
          str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_val_to_higher_line := 1
        scenario_val_to_higher_ask  := market_buy_pattern == "Bot Liq" ? bot_liq + spread  : val_level + spread 
        mid_ask := scenario_val_to_higher_ask
        open_position_mid := 1
        //
        label scenario_val_to_vah_box_label = label.new(bar_index, low, "scenario val", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_val_to_vah_box_label)
        if market_buy_pattern == "Top Compression"
            if tot_res > 0 
                take_val_to_top := old_res_1
            else
                top_data_compression := top
        if market_buy_pattern == "Val"
            pendant_trig := "Val"
        if market_buy_pattern == "Bot Liq"
            pendant_trig := "Bot Liq"
        //
    //Metto na per chiudere prima la posizione al breakout
    if not na(take_val_to_top) and vah_level < vah_level[1]
        take_val_to_top := na 
    //
    if scenario_val_to_higher_line == 1 and scenario_val_to_higher_line[1] == 1 and 
         (((high > upperEndPrice_lr or (high > top_data_compression and ema_switch_down)) and not na(top_data_compression)) or 
         (not na(take_val_to_top) and high > take_val_to_top) or 
         (na(take_val_to_top) and na(top_data_compression) and mid_lower_target_bot_trig and pendant_trig == "Bot Liq") or 
         (na(take_val_to_top) and na(top_data_compression) and mid_higher_target_bot_trig and pendant_trig == "Val"))
         and high > scenario_val_to_higher_ask
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        gain := high - scenario_val_to_higher_ask
        total_gain := total_gain + gain
        mid_ask := na
        pendant_trig := na 
        //
        label close_val_to_vah_box_label = label.new(bar_index, high, "close scenario val", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_val_to_vah_box_label)
        //
        scenario_val_to_higher_line := 0
        scenario_val_to_higher_ask  := 0
        take_val_to_top := na 
    //

// -------------------------------------}

// Buy 2 Poc position 
// -----------------------------------------------------------{

    bool scenario_poc_2_to_bot_target = false 
    if market_buy_pattern == "Poc 2 Buy Fig" or market_buy_pattern[1] == "Poc 2 Buy Fig"
        scenario_poc_2_to_bot_target := poc_2_trig and (poc_2_is_in_buy or poc_2_is_in_buy[1]) and open_position_mid == 0 and open_position_bot == 0 

    if scenario_poc_2_to_bot_target //togliere la posizione quando le cover di sotto sono aperte
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
          str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_poc_2_to_bot_target_line := 1
        scenario_poc_2_to_bot_target_ask  := poc_second_level + spread 
        mid_ask := scenario_poc_2_to_bot_target_ask
        open_position_mid := 1
        //
        label scenario_poc_2_to_bot_target_label = label.new(bar_index, low, "scenario_poc 2 to bot target", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_poc_2_to_bot_target_label)
        //
    if scenario_poc_2_to_bot_target_line == 1 and scenario_poc_2_to_bot_target_line[1] == 1 and 
         (chiusura_scenario_under_lower_lr) and high > scenario_poc_2_to_bot_target_ask
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        gain := high - scenario_poc_2_to_bot_target_ask
        total_gain := total_gain + gain
        mid_ask := na
        //
        label close_poc_2_to_bot_higher_label = label.new(bar_index, high, "close scenario poc 2 to bot target", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_poc_2_to_bot_higher_label)
        //
        scenario_poc_2_to_bot_target_line := 0
        scenario_poc_2_to_bot_target_ask  := 0
    //

// -------------------------------------}

// Buy Poc position 
// -----------------------------------------------------------{
    bool scenario_poc_to_bot_target = false 
    if market_buy_pattern == "Poc Buy Fig" or market_buy_pattern[1] == "Poc Buy Fig"
        scenario_poc_to_bot_target := poc_trig and (poc_is_in_buy or poc_is_in_buy[1]) and open_position_mid == 0 and open_position_bot == 0 

    if scenario_poc_to_bot_target //togliere la posizione quando le cover di sotto sono aperte
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
          str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_poc_to_bot_target_line := 1
        scenario_poc_to_bot_target_ask  := poc_level + spread 
        mid_ask := scenario_poc_to_bot_target_ask
        open_position_mid := 1
        //
        label scenario_poc_to_bot_target_label = label.new(bar_index, low, "scenario_poc to bot target", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_poc_to_bot_target_label)
        //
    if scenario_poc_to_bot_target_line == 1 and scenario_poc_to_bot_target_line[1] == 1 and (chiusura_scenario_under_lower_lr) and high > scenario_poc_to_bot_target_ask
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
         
        //
        gain := high - scenario_poc_to_bot_target_ask
        total_gain := total_gain + gain
        mid_ask := na
        //
        label close_poc_to_bot_higher_label = label.new(bar_index, high, "close scenario poc to bot target", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_poc_to_bot_higher_label)
        //
        scenario_poc_to_bot_target_line := 0
        scenario_poc_to_bot_target_ask  := 0
    //

// -------------------------------------}

// Buy Val position 
// -----------------------------------------------------------{

    bool scenario_val_to_bot_target = false 
    if market_buy_pattern == "Val Buy Fig" or market_buy_pattern[1] == "Val Buy Fig"
        scenario_val_to_bot_target := val_trig and (val_is_in_buy or val_is_in_buy[1])  and open_position_mid == 0 and open_position_bot == 0 

    if scenario_val_to_bot_target //togliere la posizione quando le cover di sotto sono aperte
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
          str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_val_to_bot_target_line := 1
        scenario_val_to_bot_target_ask  := val_level + spread 
        mid_ask := scenario_val_to_bot_target_ask
        //
        open_position_mid := 1
        label scenario_val_to_bot_target_label = label.new(bar_index, low, "scenario_val to bot target", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_val_to_bot_target_label)
       //
    if scenario_val_to_bot_target_line == 1 and scenario_val_to_bot_target_line[1] == 1 and (chiusura_scenario_under_lower_lr) and high > scenario_val_to_bot_target_ask
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        gain := high - scenario_val_to_bot_target_ask
        total_gain := total_gain + gain
        mid_ask := na
        //
        label close_val_to_bot_higher_label = label.new(bar_index, high, "close scenario val to bot target", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_val_to_bot_higher_label)
        //
        scenario_val_to_bot_target_line := 0
        scenario_val_to_bot_target_ask  := 0
    //

// -------------------------------------}

// Buy Vah position
// -----------------------------------------------------------{

    bool scenario_vah_to_bot_target = false 
    if market_buy_pattern == "Vah Buy Fig" or market_buy_pattern[1] == "Vah Buy Fig"
        scenario_vah_to_bot_target := vah_trig and (vah_is_in_buy or vah_is_in_buy[1])  and open_position_mid == 0 and open_position_bot == 0 

    if scenario_vah_to_bot_target //togliere la posizione quando le cover di sotto sono aperte
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
          str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_vah_to_bot_target_line := 1
        scenario_vah_to_bot_target_ask  := vah_level + spread 
        mid_ask := scenario_vah_to_bot_target_ask
        open_position_mid := 1
        //
        label scenario_vah_to_bot_target_label = label.new(bar_index, low, "scenario_vah to bot target", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_vah_to_bot_target_label)
        //
    if scenario_vah_to_bot_target_line == 1 and scenario_vah_to_bot_target_line[1] == 1 and (chiusura_scenario_under_lower_lr) and high > scenario_vah_to_bot_target_ask
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        gain := high - scenario_vah_to_bot_target_ask
        total_gain := total_gain + gain
        mid_ask := na
        //
        label close_vah_to_bot_higher_label = label.new(bar_index, high, "close scenario vah to bot target", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_vah_to_bot_higher_label)
        //
        scenario_vah_to_bot_target_line := 0
        scenario_vah_to_bot_target_ask  := 0
   //

// -------------------------------------}

// -------------------------------------}

//Conteggio posizioni e gestione secondaria dei livelli di target 
// -----------------------------------------------------------{

    open_position_mid := scenario_val_to_higher_line + scenario_poc_to_bot_target_line + scenario_val_to_bot_target_line + scenario_vah_to_bot_target_line + scenario_poc_2_to_bot_target_line
    //

// -------------------------------------}

// -------------------------------------}

// -------------------------------------}

// Buy Bot + Cover position ID DA 1 A 11
// -----------------------------------------------------------{

// Posizione Bot liq/ primo pivot
// -----------------------------------------------------------{

// Buy actual support over bot 
// -----------------------------------------------------------{

    scenario_actual_over_bot = actual_support_over_bot_perc < 50 and actual_supporto > bot and bot_is_sup and low[1] > actual_supporto and low < actual_supporto and actual_supporto == actual_supporto[1] and actual_supporto < mid_ask and tot_position_scenario_bot == 0 and not cover_1_line

    if scenario_actual_over_bot and open_position_break == 0 
        n_posizione := 11
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
          str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_actual_over_bot_line := 1
        scenario_actual_over_bot_ask  := low + spread * 2
        //
        label scenario_actual_over_bot_label = label.new(bar_index, low - (high - low), "scenario actual over bot", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_actual_over_bot_label)

    if scenario_actual_over_bot_line == 1 and scenario_actual_over_bot_line[1] == 1 and ((high > upperEndPrice_lr[1] or actual_support_trig) or (ema_switch_down and cover_1_line)) and high > scenario_actual_over_bot_ask
        n_posizione := 11
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        if high > mid_ask 
            n_posizione := 12
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            close_alarm_mid := true
            label close_alarm_mid_label = label.new(bar_index, high + high - low, "close alarm mid", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, close_alarm_mid_label)
            gain := high - mid_ask 
            total_gain := total_gain + gain 
        //
        gain := high - scenario_actual_over_bot_ask
        total_gain := total_gain + gain
        //
        label close_actual_over_bot = label.new(bar_index, high, "close actual over bot", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_actual_over_bot)
        //
        scenario_actual_over_bot_line := 0
        scenario_actual_over_bot_ask  := 0
    //

// -------------------------------------}

    //Posizione supporto (old o attuale)
    scenario_bot   = bot_liq_trig and bot_is_sup and not scenario_bot_line and not scenario_bot_2_line and not cover_1_line[1]
    scenario_bot_down = low < bot[1] and bot_is_sup[1] and not scenario_bot_line and not scenario_bot_2_line 

    scenario_bot_2 = old_sup_trig and not bot_is_sup and not scenario_bot_line and not scenario_bot_2_line and not cover_1_line[1]
    //Salvo due blocchi diversi di livelli cover a parte in modo da non raddoppiare la successiva iterazione del codice.
    if (scenario_bot or scenario_bot_down) and not scenario_bot_line
        scenario_bot_line   := true 
        first_bot_liq := bot_liq
        if not na(old_sup)
            supporto_1 := old_sup
        if not na(old_sup_1)
            supporto_2 := old_sup_1
        if not na(old_sup_2)
            supporto_3 := old_sup_2
        if not na(old_sup_3)
            supporto_4 := old_sup_3
        //
    if scenario_bot_2 and not scenario_bot_2_line
        scenario_bot_2_line := true 
        first_bot_liq := bot_liq
        if not na(old_sup_1)
            supporto_1 := old_sup_1
        if not na(old_sup_2)
            supporto_2 := old_sup_2
        if not na(old_sup_3)
            supporto_3 := old_sup_3
        //
    scenario_bot_siffredi = market_buy_pattern == "Siffredi" and high > top_liq

    //Iterazioni quando bot_is_sup  
    if scenario_bot_line
        
        if (scenario_bot and scenario_bot_line_to_l == 0) or (scenario_bot_down and scenario_bot_line_to_l == 0)
            n_posizione := 1 
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
            //
            scenario_bot_line_to_l := 1
            scenario_bot_ask_to_l  := scenario_bot ? (bot_liq[1] + spread) : (bot[1] + spread)
            //
            label scenario_bot_label = label.new(bar_index, low, "scenario_bot l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_label)

        //
        if scenario_bot and scenario_bot_line_to_h == 0 and (open_position_break + open_position_mid) < 2 //togliere la posizione quando le cover di sotto sono aperte
            n_posizione := 2
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
            //
            scenario_bot_line_to_h := 1 
            scenario_bot_ask_to_h  := bot_liq[1] + spread 
            //
            label scenario_bot_2_label = label.new(bar_index, low, "scenario_bot h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_2_label)

        //Attualmente molte chiusure si chiudono in un banale overbuy, sarà opportuno adattare lo studio del pearson anche a questo gruppo di chiusure 

        if scenario_bot_line_to_l == 1 and scenario_bot_line_to_l[1] == 1 and ((lower_target_bot_trig) or (ema_switch_down and cover_1_line)) and high > scenario_bot_ask_to_l
            n_posizione := 1
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            if high > mid_ask and not na(mid_ask)
                n_posizione := 12
                alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
                 \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
                close_alarm_mid := true
                label close_alarm_mid_label = label.new(bar_index, high + high - low, "close alarm mid", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
                array.push(saved_labels, close_alarm_mid_label)
                gain := high - mid_ask 
                total_gain := total_gain + gain 
            //
            gain := high - scenario_bot_ask_to_l
            total_gain := total_gain + gain
            //
            label scenario_bot_close_label_l = label.new(bar_index, high, "close scenario_bot l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_close_label_l)
            //
            scenario_bot_line_to_l := 0
            scenario_bot_ask_to_l  := 0
        //

        if scenario_bot_line_to_h == 1 and scenario_bot_line_to_h[1] == 1 and ((higher_target_bot_trig) or (ema_switch_down and cover_2_line)) and high > scenario_bot_ask_to_h
            n_posizione := 2
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            //
            gain := high - scenario_bot_ask_to_h
            total_gain := total_gain + gain
            //
            label scenario_bot_close_label_h = label.new(bar_index, high, "close scenario_bot h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_close_label_h)
            //
            scenario_bot_line_to_h := 0
            scenario_bot_ask_to_h  := 0
        //
    //Iterazioni quando not bot_is_sup 
    if scenario_bot_2_line 
        
        if scenario_bot_2 and scenario_bot_line_to_l == 0 and (scenario_actual_over_bot_line == 0)
            n_posizione := 1
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
            //
            scenario_bot_line_to_l := 1
            scenario_bot_ask_to_l  := old_sup + spread 
            //
            label scenario_bot_label = label.new(bar_index, low, "scenario_bot l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_label)

        //
        if scenario_bot_2 and scenario_bot_line_to_h == 0 and (open_position_break + open_position_mid) < 2 //togliere la posizione quando le cover di sotto sono aperte
            n_posizione := 2
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
            //
            scenario_bot_line_to_h := 1 
            scenario_bot_ask_to_h  := old_sup + spread 
            //
            label scenario_bot_2_label = label.new(bar_index, low, "scenario_bot h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_2_label)

        //Attualmente molte chiusure si chiudono in un banale overbuy, sarà opportuno adattare lo studio del pearson anche a questo gruppo di chiusure 

        if scenario_bot_line_to_l == 1  and scenario_bot_line_to_l[1] == 1 and ((lower_target_bot_trig or cover_1_line)) and high > scenario_bot_ask_to_l
            n_posizione := 1
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            //
            gain := high - scenario_bot_ask_to_l
            total_gain := total_gain + gain
            //
            label scenario_bot_close_label_l = label.new(bar_index, high, "close scenario_bot l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_close_label_l)
            //
            scenario_bot_line_to_l := 0
            scenario_bot_ask_to_l  := 0
        //
        if scenario_bot_line_to_h == 1 and scenario_bot_line_to_h[1] == 1 and ((higher_target_bot_trig) or (scenario_bot_siffredi) or (ema_switch_down and cover_2_line)) and high > scenario_bot_ask_to_h
            n_posizione := 2
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            if high > mid_ask and not na(mid_ask)
                n_posizione := 12
                alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
                 \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
                close_alarm_mid := true
                label close_alarm_mid_label = label.new(bar_index, high + high - low, "close alarm mid", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
                array.push(saved_labels, close_alarm_mid_label)
                gain := high - mid_ask 
                total_gain := total_gain + gain 
            //
            //
            gain := high - scenario_bot_ask_to_h
            total_gain := total_gain + gain
            //
            label scenario_bot_close_label_h = label.new(bar_index, high, "close scenario_bot h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_close_label_h)
            //
            scenario_bot_line_to_h := 0
            scenario_bot_ask_to_h  := 0
        //
// -------------------------------------}

//Pulisco i livelli di bot e i supporti quando le posizioni sono tutte chiuse - definisco le variabili di cover
// -------------------------------------{

    tot_position_scenario_bot := scenario_bot_line_to_l + scenario_bot_line_to_h + scenario_actual_over_bot_line
    //Chiusura della line di scenario bot quando non ci sono operazioni aperte
    if tot_position_scenario_bot == 0 and scenario_bot_line 
        scenario_bot_line := false 
        supporto_1 := na 
        supporto_2 := na 
        supporto_3 := na 
        supporto_4 := na 
    //
    if tot_position_scenario_bot == 0 and scenario_bot_2_line
        scenario_bot_2_line := false 
        supporto_1 := na 
        supporto_2 := na 
        supporto_3 := na 
        supporto_4 := na 
    //

    if scenario_bot_line or scenario_bot_2_line
        supporto_cover_trig_1 := not na(supporto_1[1]) and low[1] > supporto_1[1] and low <= supporto_1[1] and not cover_1_line and not cover_2_line
        supporto_cover_trig_2 := not na(supporto_2[1]) and low[1] > supporto_2[1] and low <= supporto_2[1] and not cover_2_line and not cover_3_line
        supporto_cover_trig_3 := not na(supporto_3[1]) and low[1] > supporto_3[1] and low <= supporto_3[1] and not cover_3_line and not cover_4_line
        supporto_cover_trig_4 := not na(supporto_4[1]) and low[1] > supporto_4[1] and low <= supporto_4[1] and not cover_4_line
    //

// -------------------------------------}

//Posizione cover 1
// -------------------------------------{

    if supporto_cover_trig_1
        cover_1_line := true 
    //
    //Aperture
    if cover_1_line
        if supporto_cover_trig_1 and scenario_cover_1_line_to_h == 0
            n_posizione := 3
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_1_line_to_h := 1 
            scenario_cover_1_ask_to_h  := supporto_1 + spread 
            //
            label scenario_cover_1_label_h = label.new(bar_index, low, "scenario_cover_1 h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_1_label_h)

        if supporto_cover_trig_1 and scenario_cover_1_line_to_l == 0
            n_posizione := 4
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_1_line_to_l := 1 
            scenario_cover_1_ask_to_l  := supporto_1 + spread 
            //
            label scenario_cover_1_label_l = label.new(bar_index, low, "scenario_cover_1 l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_1_label_l)
        //
        //Chiusure
        if scenario_cover_1_line_to_l == 1 and ((low_trig) or (ema_switch_down and cover_2_line) or (high > scenario_bot_ask_to_h and not na (scenario_bot_ask_to_h)))  and high > scenario_cover_1_ask_to_l
            n_posizione := 4
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            gain := high - scenario_cover_1_ask_to_l
            total_gain := total_gain + gain
            //
            label scenario_cover_1_close_label_l = label.new(bar_index, high, "close scenario_cover_1 l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_1_close_label_l)
            //
            scenario_cover_1_line_to_l := 0
            scenario_cover_1_ask_to_l  := 0
            supporto_1 := bot
            supporto_2 := old_sup
            supporto_3 := old_sup_1
            supporto_4 := old_sup_2
            //
        if scenario_cover_1_line_to_h == 1 and ((high_trig) or (ema_switch_down and cover_3_line)) and high > scenario_cover_1_ask_to_h
            n_posizione := 3
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            gain := high - scenario_cover_1_ask_to_h
            total_gain := total_gain + gain
            //
            label scenario_cover_1_close_label_h = label.new(bar_index, high, "close scenario_cover_1 h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_1_close_label_h)
            //
            scenario_cover_1_line_to_h := 0
            scenario_cover_1_ask_to_h  := 0
            supporto_1 := bot_liq
            supporto_2 := old_sup
            supporto_3 := old_sup_1
            supporto_4 := old_sup_2
            //
        tot_position_scenario_cover_1 := scenario_cover_1_line_to_l + scenario_cover_1_line_to_h
        //Chiusura della line di scenario bot quando non ci sono operazioni aperte
        if tot_position_scenario_cover_1 == 0 and cover_1_line
            cover_1_line := false 
        //

// -------------------------------------}

//Posizione cover 2
// -------------------------------------{

    if supporto_cover_trig_2
        cover_2_line := true 
    //
    //Aperture
    if cover_2_line
        if supporto_cover_trig_2 and scenario_cover_2_line_to_h == 0
            n_posizione := 5
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_2_line_to_h := 1 
            scenario_cover_2_ask_to_h  := supporto_2 + spread 
            //
            label scenario_cover_2_label_h = label.new(bar_index, low, "scenario_cover_2 h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_2_label_h)

        if supporto_cover_trig_2 and scenario_cover_2_line_to_l == 0
            n_posizione := 6
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_2_line_to_l := 1 
            scenario_cover_2_ask_to_l  := supporto_2 + spread 
            //
            label scenario_cover_2_label_l = label.new(bar_index, low, "scenario_cover_2 l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_2_label_l)
        //
        //Chiusure
        if scenario_cover_2_line_to_l == 1 and ((low_trig) or (ema_switch_down and cover_3_line) or (high > scenario_cover_1_ask_to_h and not na(scenario_cover_1_ask_to_h))) and high > scenario_cover_2_ask_to_l
            n_posizione := 6
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            gain := high - scenario_cover_2_ask_to_l
            total_gain := total_gain + gain
            //
            label scenario_cover_2_close_label_l = label.new(bar_index, high, "close scenario_cover_2 l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_2_close_label_l)
            //
            scenario_cover_2_line_to_l := 0
            scenario_cover_2_ask_to_l  := 0
            supporto_2 := bot
            supporto_3 := old_sup
            supporto_4 := old_sup_1
            //
        if scenario_cover_2_line_to_h == 1 and ((high_trig) or (ema_switch_down and cover_4_line)) and high > scenario_cover_2_ask_to_h
            n_posizione := 5
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            gain := high - scenario_cover_2_ask_to_h
            total_gain := total_gain + gain
            //
            label scenario_cover_2_close_label_h = label.new(bar_index, high, "close scenario_cover_2 h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_2_close_label_h)
            //
            scenario_cover_2_line_to_h := 0
            scenario_cover_2_ask_to_h  := 0
            supporto_2 := bot_liq
            supporto_3 := old_sup
            supporto_4 := old_sup_1
            //
        tot_position_scenario_cover_2 := scenario_cover_2_line_to_l + scenario_cover_2_line_to_h
        //Chiusura della line di scenario bot quando non ci sono operazioni aperte
        if tot_position_scenario_cover_2 == 0 and cover_2_line
            cover_2_line := false 
        //

// -------------------------------------}

//Posizione cover 3
// -------------------------------------{

    if supporto_cover_trig_3
        cover_3_line := true 
    //
    //Aperture
    if cover_3_line
        if supporto_cover_trig_3 and scenario_cover_3_line_to_h == 0
            n_posizione := 7
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_3_line_to_h := 1 
            scenario_cover_3_ask_to_h  := supporto_3 + spread 
            //
            label scenario_cover_3_label_h = label.new(bar_index, low, "scenario_cover_3 h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_3_label_h)

        if supporto_cover_trig_3 and scenario_cover_3_line_to_l == 0
            n_posizione := 8
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_3_line_to_l := 1 
            scenario_cover_3_ask_to_l  := supporto_3 + spread 
            //
            label scenario_cover_3_label_l = label.new(bar_index, low, "scenario_cover_3 l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_3_label_l)
        //
        //Chiusure
        if scenario_cover_3_line_to_l == 1 and ((low_trig) or (ema_switch_down and cover_4_line) or (high > scenario_cover_2_ask_to_h and not na(scenario_cover_2_ask_to_h)))  and high > scenario_cover_3_ask_to_l
            n_posizione := 8
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            gain := high - scenario_cover_3_ask_to_l
            total_gain := total_gain + gain
            //
            label scenario_cover_3_close_label_l = label.new(bar_index, high, "close scenario_cover_3 l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_3_close_label_l)
            //
            scenario_cover_3_line_to_l := 0
            scenario_cover_3_ask_to_l  := 0
            supporto_3 := bot
            supporto_4 := old_sup
        //
        if scenario_cover_3_line_to_h == 1 and high_trig and high > scenario_cover_3_ask_to_h
            n_posizione := 7
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            gain := high - scenario_cover_3_ask_to_h
            total_gain := total_gain + gain
            //
            label scenario_cover_3_close_label_h = label.new(bar_index, high, "close scenario_cover_3 h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_3_close_label_h)
            //
            scenario_cover_3_line_to_h := 0
            scenario_cover_3_ask_to_h  := 0
            supporto_3 := bot_liq
            supporto_4 := old_sup
        //
        tot_position_scenario_cover_3 := scenario_cover_3_line_to_l + scenario_cover_3_line_to_h
        //Chiusura della line di scenario bot quando non ci sono operazioni aperte
        if tot_position_scenario_cover_3 == 0 and cover_3_line
            cover_3_line := false 
        //

// -------------------------------------}

//Posizione cover 4
// -------------------------------------{

    if supporto_cover_trig_4
        cover_4_line := true 
    //
    //Aperture
    if cover_4_line
        if supporto_cover_trig_4 and scenario_cover_4_line_to_h == 0
            n_posizione := 9
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_4_line_to_h := 1 
            scenario_cover_4_ask_to_h  := supporto_4 + spread 
            //
            label scenario_cover_4_label_h = label.new(bar_index, low, "scenario_cover_4 h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_4_label_h)

        if supporto_cover_trig_4 and scenario_cover_4_line_to_l == 0
            n_posizione := 10
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_4_line_to_l := 1 
            scenario_cover_4_ask_to_l  := supporto_4 + spread 
            //
            label scenario_cover_4_label_l = label.new(bar_index, low, "scenario_cover_4 l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_4_label_l)
        //
        //Chiusure
        if scenario_cover_4_line_to_l == 1 and (low_trig or (high > scenario_cover_3_ask_to_h and not na(scenario_cover_3_ask_to_h)))  and high > scenario_cover_4_ask_to_l
            n_posizione := 10
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            gain := high - scenario_cover_4_ask_to_l
            total_gain := total_gain + gain
            //
            label scenario_cover_4_close_label_l = label.new(bar_index, high, "close scenario_cover_4 l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_4_close_label_l)
            //
            scenario_cover_4_line_to_l := 0
            scenario_cover_4_ask_to_l  := 0
            supporto_4 := bot
            //
        if scenario_cover_4_line_to_h == 1 and (high_trig) and high > scenario_cover_4_ask_to_h
            n_posizione := 9
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            gain := high - scenario_cover_4_ask_to_h
            total_gain := total_gain + gain
            //
            label scenario_cover_4_close_label_h = label.new(bar_index, high, "close scenario_cover_4 h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_4_close_label_h)
            //
            scenario_cover_4_line_to_h := 0
            scenario_cover_4_ask_to_h  := 0
            supporto_4 := bot_liq
        //
        tot_position_scenario_cover_4 := scenario_cover_4_line_to_l + scenario_cover_4_line_to_h
        //Chiusura della line di scenario bot quando non ci sono operazioni aperte
        if tot_position_scenario_cover_4 == 0 and cover_4_line
            cover_4_line := false 
        //

// -------------------------------------}

// -------------------------------------}

// Iterazioni di run out candle e tabella finale 
// -----------------------------------------------------------{

//Contatore BBars aggiornato a fine iterazione per evitare bar + 1 nel contatore candele
if run > 0 and contatore < (bar_limit - original_bbars) and block_start_bar and ancoraggio_pivot
    contatore += 1 
//if run > 1 and contatore < (bar_limit - bbars) and block_start_bar and not ancoraggio_pivot and (bar_index[bbars] -1) == support_switch_bar //Sezione da verificare, non sono sicuro che ancori correttamente al pivot
//    contatore += 1
//
if block_start_bar and switch_supporto and not na(save_bot_liq)
    save_bot_liq := na
    save_top_liq := na
//
 
if run > 0 and (contatore + bbars) >= bar_limit and block_start_bar and na(save_bot_liq)
    save_bot_liq := bot_liq
    save_top_liq := top_liq
//

fib_distance = fib_vah_value - fib_val_value

if fib_distance > 3 and run > 0 and mid_level_vol < 4
    percent -= 5
if fib_distance < 3 and run > 0 and mid_level_vol < 4
    percent += 5
//

//
if run > 1 and not show_plot
    line.delete(baseLine_lr)
    line.delete(upper_lr)
    line.delete(lower_lr)
    for x = 0 to cnum - 1 by 1
        box.delete(array.get(vol_bars, x))
        box.delete(array.get(vol_bars, x + cnum))
//
tot_position_cover := tot_position_scenario_cover_1 + tot_position_scenario_cover_2 + tot_position_scenario_cover_3 + tot_position_scenario_cover_4
tot_position := tot_position_cover + open_position_break + open_position_bot + open_position_mid

if run == 2 and bbars == bar_limit
    alert("Bar Limit Reach",alert.freq_once_per_bar)
    run += 1
//

// -------------------------------------}

// Tabella
// -----------------------------------------------------------{

low_cover_level = tot_sup == 4 ? old_sup_3 : tot_sup == 3 ? old_sup_2 : tot_sup == 2 ? old_sup_1 : tot_sup == 1 ? old_sup : na 

// Calcola la differenza percentuale
diff_percentage = 100 - (((low_cover_level / close ) * 100))

// Tabella unificata con informazioni di livelli e volumi
if show_plot or not show_plot

    // Tabella unificata con tutte le informazioni
    var table unifiedTable = table.new(position.middle_right, 4, 10, color.new(color.black, 80), 
                                     border_width=1, border_color=color.new(color.gray, 60),
                                     force_overlay=true)

    if barstate.isconfirmed or run == 1
        
        // ===== SEZIONE MARKET STATUS =====
        table.cell(unifiedTable, 0, 0, "MARKET STATUS", text_color=color.white, 
                 bgcolor=headerColor, text_halign=text.align_center)
        table.merge_cells(unifiedTable, 0, 0, 3, 0)
        
        // Prima riga Market Status
        table.cell(unifiedTable, 0, 1, "TRD", text_color=color.white, 
                 bgcolor=color.new(color.gray, 40), text_halign=text.align_center)
        table.cell(unifiedTable, 1, 1, "M", text_color=color.white, 
                 bgcolor=color.new(color.gray, 40), text_halign=text.align_center)
        table.cell(unifiedTable, 2, 1, "PRS", text_color=color.white, 
                 bgcolor=color.new(color.gray, 40), text_halign=text.align_center)
        table.cell(unifiedTable, 3, 1, "DISP", text_color=color.white, 
                 bgcolor=color.new(color.gray, 40), text_halign=text.align_center)
        
        // Valori Market Status
        table.cell(unifiedTable, 0, 2, ((percent_change >= 0 ? "+" : "") + 
                 str.tostring(percent_change, "#.##") + "%"), text_color=color.white, 
                 bgcolor=percent_change >= 0 ? positiveColor : negativeColor, 
                 text_halign=text.align_center)
        table.cell(unifiedTable, 1, 2, ((m >= 0 ? "+" : "") + str.tostring(m, "#.##") + "%"), 
                 text_color=color.white, bgcolor=m >= 0 ? positiveColor : negativeColor, 
                 text_halign=text.align_center)
        table.cell(unifiedTable, 2, 2, real_pearson >= 0 ? "+" + str.tostring(real_pearson, "#.##") : str.tostring(real_pearson, "#.##"), 
                 text_color=color.white, bgcolor=real_pearson >= 0 ? positiveColor : negativeColor, 
                 text_halign=text.align_center)
        table.cell(unifiedTable, 3, 2, volume_dispersion, text_color=color.white, 
                 bgcolor=color.new(color.black, 70), text_halign=text.align_center)
        
        // Market, Pattern, Bars
        table.cell(unifiedTable, 0, 3, "MKT", text_color=color.white, 
                 bgcolor=color.new(color.gray, 40), text_halign=text.align_center)
        table.cell(unifiedTable, 1, 3, market, text_color=color.white, 
                 bgcolor=color.new(color.black, 70), text_halign=text.align_center)
        
        table.cell(unifiedTable, 2, 3, "PTN", text_color=color.white, 
                 bgcolor=color.new(color.gray, 40), text_halign=text.align_center)
        table.cell(unifiedTable, 3, 3, market_buy_pattern, text_color=color.white, 
                 bgcolor=color.new(color.black, 70), text_halign=text.align_center)
                 
        // Barre
        table.cell(unifiedTable, 0, 4, "BARS", text_color=color.white, 
                 bgcolor=color.new(color.gray, 40), text_halign=text.align_center)
        table.cell(unifiedTable, 1, 4, block_start_bar ? "🟢" : "🔴", text_color=color.white, 
                 bgcolor=block_start_bar ? color.new(color.green, 60) : color.new(color.red, 60), 
                 text_halign=text.align_center)
                 
        // Utilizzo spazio vuoto in modo efficace
        table.cell(unifiedTable, 2, 4, "", text_color=color.white, 
                 bgcolor=color.new(color.gray, 40), text_halign=text.align_center)
        table.cell(unifiedTable, 3, 4, "", text_color=color.white, 
                 bgcolor=color.new(color.black, 70), text_halign=text.align_center)

        // ===== SEPARATORE =====
        table.cell(unifiedTable, 0, 5, "", text_color=color.white, bgcolor=color.new(color.black, 50))
        table.merge_cells(unifiedTable, 0, 5, 3, 5)
        
        // ===== SEZIONE LIVELLI & STATUS =====
        table.cell(unifiedTable, 0, 6, "LIVELLI & STATUS", text_color=color.white, 
                 bgcolor=headerColor, text_halign=text.align_center)
        table.merge_cells(unifiedTable, 0, 6, 3, 6)
        
        // Prima riga: Support & Resistance
        table.cell(unifiedTable, 0, 7, "SUP", text_color=color.white, 
                 bgcolor=bot_is_sup ? color.new(color.green, 40) : color.new(color.gray, 40),
                 text_halign=text.align_center)
        table.cell(unifiedTable, 1, 7, str.tostring(bot, "#.##"), text_color=color.white, 
                 bgcolor=color.new(color.black, 70), text_halign=text.align_center)
        
        table.cell(unifiedTable, 2, 7, "RES", text_color=color.white, 
                 bgcolor=top_is_res ? color.new(color.red, 40) : color.new(color.gray, 40),
                 text_halign=text.align_center)
        table.cell(unifiedTable, 3, 7, str.tostring(top, "#.##"), text_color=color.white, 
                 bgcolor=color.new(color.black, 70), text_halign=text.align_center)
        
        // Seconda riga: Totali Sup/Res
        table.cell(unifiedTable, 0, 8, "TOT SUP", text_color=color.white, 
                 bgcolor=color.new(color.gray, 40), text_halign=text.align_center)
        table.cell(unifiedTable, 1, 8, str.tostring(tot_sup), text_color=color.white, 
                 bgcolor=tot_sup > 0 ? color.new(color.green, 60) : color.new(color.black, 70),
                 text_halign=text.align_center)
        
        table.cell(unifiedTable, 2, 8, "TOT RES", text_color=color.white, 
                 bgcolor=color.new(color.gray, 40), text_halign=text.align_center)
        table.cell(unifiedTable, 3, 8, str.tostring(tot_res), text_color=color.white, 
                 bgcolor=tot_res > 0 ? color.new(color.red, 60) : color.new(color.black, 70),
                 text_halign=text.align_center)
        
        // Terza riga: Old Sup/Old Sup 1
        table.cell(unifiedTable, 0, 9, "OLD SUP", text_color=color.white, 
                 bgcolor=color.new(color.gray, 40), text_halign=text.align_center)
        table.cell(unifiedTable, 1, 9, str.tostring(old_sup, "#.##"), text_color=color.white, 
                 bgcolor=color.new(color.black, 70), text_halign=text.align_center)
                 
        table.cell(unifiedTable, 2, 9, "Gestione:", text_color=color.white, 
                 bgcolor=color.new(color.gray, 40), text_halign=text.align_center)
        table.cell(unifiedTable, 3, 9, (str.tostring(diff_percentage, "#.##") + "%"), text_color=color.white, 
                 bgcolor=color.new(color.black, 70), text_halign=text.align_center)
    //

// -------------------------------------}
 
// Tabella con la variabile bbars
var table bbars_table = table.new(position.middle_left, 1, 1, border_color=color.new(#151715, 70), bgcolor=color.new(#151715, 70), frame_color=color.new(#151715, 0), frame_width=1, force_overlay = false)
if barstate.islast
    table.cell(bbars_table, 0, 0, "Barre: " + str.tostring(bbars), text_color=color.white, bgcolor=color.new(#151715, 70))
//
// Tabella per visualizzare le variabili in un pannello separato
plotTable = table.new(position.bottom_right, columns = 2, rows = 5, bgcolor = color.new(color.black, 70), border_width = 1, force_overlay = false)

// Aggiorna la tabella con i valori correnti
table.cell(plotTable, 0, 0, "Titolo", text_color = color.white, bgcolor = color.new(color.blue, 90))
table.cell(plotTable, 1, 0, titolo, text_color = color.white)
table.cell(plotTable, 0, 1, "Spread", text_color = color.white, bgcolor = color.new(color.blue, 90))
table.cell(plotTable, 1, 1, str.tostring(spread), text_color = color.white)
table.cell(plotTable, 0, 2, "N. Titoli", text_color = color.white, bgcolor = color.new(color.blue, 90))
table.cell(plotTable, 1, 2, str.tostring(n_titoli), text_color = color.white)
table.cell(plotTable, 0, 3, "Dist. Cover", text_color = color.white, bgcolor = color.new(color.blue, 90))
table.cell(plotTable, 1, 3, str.tostring(media_vol, "#.##"), text_color = color.white)
